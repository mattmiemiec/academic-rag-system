{
  "filename": "2509.12502v2.pdf",
  "total_chunks": 26,
  "text_length": 102993,
  "chunks": [
    "Enlarging the GKP stabilizer group for enhanced noise protection Jonathan Pelletier1,2and Baptiste Royer1,2 1Département de Physique, Université de Sherbrooke, Sherbrooke, Qc. J1K 2R1, Canada 2Institut Quantique, Université de Sherbrooke, Sherbrooke, Qc. J1K 2R1, Canada Encoding a qubit in a larger Hilbert space of an oscillator is an efficient way to protect its quantum information against decoherence. Promising examples of such bosonic encodings are the Gottesman-Kitaev-Preskill (GKP) codes. In this work, we investigate how redefining the stabilizer group of the GKP codes to include all operations with trivial action on the code space can contribute to the search for an optimal implementation of a logical circuit when it is affected by noise. We find the generators of the Gaussian stabilizer group, allowing us to search for different physical implementations of a Clifford operation. We then propose an algorithm that finds the optimal implementation of a given logical Clifford circuit on GKP codes, such that the state is less affected by loss errors during the computation. Finally, we demonstrate numerically, with logicalrandomizedbenchmarking, thatsuchacompilercanincreasethelifetime of square-GKP qubits while running Clifford circuits, compared to a random walk compiler. 1 Introduction As we move toward and beyond advanced noisy intermediate-scale quantum computing, the roles of quantum error correction (QEC) and compilation techniques become increas- ingly important. QEC ensures that the errors caused by decoherence channels during a computation do not accumulate too quickly, while compilation techniques can reduce the rate at which they occur in the first place. The combination of both is essential to move toward fault-tolerant computations and useful applications. QEC consist of redundantly encoding quantum information in a larger quantum system such that small physical errors can be detected and corrected before the full system is affected by its spreading. Systems that enable bosonic encodings are promising platforms for QEC, where the Hilbert space of possibly many high-quality harmonic oscillator modes can be used to encode quantum information. The increase in the ratio of redundancy over the number of physical devices needed compared to other options, like qubit codes, is an encouraging perspective toward the scaling of such implementations in a hardware-efficient manner. Bosonic codes can be implemented in many architectures, such as cavity quantum electrodynamics [1, 2, 3, 4], optical modes [5, 6] and trapped ions [7, 8, 9], to cite only a few. Amplitude damping (bosonic loss) is the main type of error channel affecting those architectures, followed by dephasing and other higher-order non-linear processes. The code introduced by Gottes- man, Kitaev and Preskill (GKP) [10] can correct small displacement errors, and has been observed to be very efficient to protect against amplitude damping, while remaining com- 1arXiv:2509.12502v2 [quant-ph] 24 Sep 2025 petitive against other types of noise [11, 12]. This has created a lot of interest to study the limitations of GKP codes and potential ways to achieve universal quantum computation. For example, with the ability to apply arbitrary Clifford gates, it is possible to achieve uni- versal computation with the addition of magic state injection [13]. This path to universal computation is particularly interesting for GKP codes because Clifford operations",
    "GKP codes and potential ways to achieve universal quantum computation. For example, with the ability to apply arbitrary Clifford gates, it is possible to achieve uni- versal computation with the addition of magic state injection [13]. This path to universal computation is particularly interesting for GKP codes because Clifford operations can be realized with Gaussian operations only, for which the spread of displacement error can be controlled. If we instead consider finite-energy GKP codes and the bosonic loss, the effect of the error channel becomes dependent on the particular Gaussian operations used to im- plement the logical operation. Solving this issue and finding good compiling algorithms for Clifford circuits on finite energy GKP codes is then crucial to achieve universal quantum computing with bosonic codes. In the present work, we study this problem of finding an optimal implementation of a Clifford circuit on a multimode finite energy GKP encoding, while it is affected by bosonic loss. To attain this goal, we first identify all logically equivalent implementations of a given logical operation on the ideal code. It is parametrized by the stabilizer group, which we define here to be the (potentially non-abelian) group of all operations that stabilize the code space. This leads us to include the standard translations symmetries of GKP codes, but also an infinite number of non-commuting stabilizers. Focusing on Clifford operations, we restrict this group to Gaussian operations and define the Gaussian GKP stabilizer group. Along the way, we solve a quadratic matrix equation over the restricted ring of integer matrices to fully characterize the generators of the group. Moving on to an application on finite energy GKP, we find that each GKP codeword implementation can be described by a general Fock-type envelope that generalizes the concept of finite-energy GKP codewords [14]. For the sake of completeness, we include an updated version of the so-called small-Big-small (sBs) stabilization protocol for those codewords. We find that the logical information contained within a finite energy GKP state is independant of the envelope, and is only dependant on the underlying logical grid, which create redundancy on how we choose to implement a logical state. A consequence of the redundancy is that choosing a specific implementation of a gate is equivalent to choosing an implementation of a codeword, which is also equivalent to choosing an envelope. This enables us to find clear optimization criteria on Clifford circuits based on the characteristics of the bosonic loss channel and their effects on the envelope of the codewords. In the last part of this work, we propose an algorithm that compiles Clifford circuits using those criteria. Finally, we use logical randomized benchmarking to compare our compiler algorithm to a random walk compiler algorithm [15] and show the gain of using the former. In the appendices, we included supplementary results that are more technical, but still of interest for the community. In Sect. B, we present the generalization of the sBs protocol to any Fock- type envelope. In Sects. C to E, we included a derivation of the Wigner function of the codespace projector for any",
    "we included supplementary results that are more technical, but still of interest for the community. In Sect. B, we present the generalization of the sBs protocol to any Fock- type envelope. In Sects. C to E, we included a derivation of the Wigner function of the codespace projector for any GKP code, the derivation of the Wigner function of any finite energy GKP grid state and a computation of the number of excition contained in a finite energy GKP grid state, respectively. The paper is organized as follows. We start in Sect. 2 with useful definitions and notations on GKP codes, their representation and operations on harmonic oscillators. In Sect. 3, we present and characterize the Gaussian stabilizer group for GKP codes. It is followed by its application on finite energy GKP codes to find optimization criteria in Sect. 4. In Sect. 5, we introduce our compiler algorithm and analyze its performance. We conclude in Sect. 6. 2 2 Preliminaries and notation In this section, we review the construction of multimode GKP codes as lattice codes [10, 16, 17, 18]. GKP codes are stabilizer codes which use the infinite-dimensional quantum Hilbert space ofNbosonic modes to encode a finite-dimensional logical subspace. We denote the creation and annihilation operators for thekthmode asˆa kandˆa† k, respectively, with commutation relation[ˆa j,ˆa† k] =δj,kforj,k= 1,...,N. We also make use of the quadrature coordinatesˆq k= (ˆak+ ˆa† k)/√ 2andˆpk=−i(ˆak−ˆa† k)/√ 2withℏ= 1. We arrange these coordinates in a vector of operators ˆξ= (ˆ q,ˆ p)Tin theqqppconvention such that the commutation relation becomes[ ˆξj,ˆξk] =iΩjkforj,k= 1,...,2N. The matrix Ω2N=/parenleftigg 0 1 −1 0/parenrightigg ⊗IN (1) gives rise to the skew-symmetric bilinear form (symplectic form) ω(u,v) =uTΩv,(2) defined foru,v∈R2N. We omit the subscript ofΩ 2Nwhen the dimension is clear from the context. We define the translation operator as ˆT(v) = e−ilvTΩˆξ,(3) from which the relation ˆT(u) ˆT(v) = e−il2uTΩvˆT(v) ˆT(u) = e−il2 2uTΩvˆT(u+v)(4) is implied by the commutation relation defined before. When using translations with units ofl=√ 2π, thecommutativityoftwotranslationoperatorsistantamounttothesymplectic form being an integer: [ˆT(u), ˆT(v)] = 0⇐⇒ω(u,v)∈Z.(5) These translation operators form representations of the Heisenberg groupH 2N+1 (R)on the infinite Hilbert space ofNoscillators. GKP codes are stabilizer codes which use this structure to embed one or multiple finite-dimensional representations of the Weyl- Heisenberg group on a finite-dimensional logical subspace using the translation operators. In more detail, the stabilizer of a GKP code is an abelian group generated by a set of2N translation operators S=/angbracketleftigˆT(s1),ˆT(s2),..., ˆT(s2N)/angbracketrightig ,(6) with{sj}a basis forR2N. The abelianity condition ofStranslate to the matrix A=SΩST(7) being integral, where the matrixSis constructed from{s j}as row vectors. We refer toA as the symplectic Gram matrix. The GKP stabilizer group is then isomorphic to a lattice Λ⊂R2Ngenerated by the matrixSwith the elements given by Λ ={STa|a∈Z2N}.(8) In the stabilizer formalism, we obtain the generalized logical Pauli operators as operators that commute with all of the stabilizers, but are not in the stabilizer:C(S)/S. Using the 3 isomorphism between the stabilizer group and the latticeΛ, we can show that the Pauli operators coincide with the definition of the symplectic dual latticeΛ∗ Λ∗={u|SΩu∈Z2N}.(9) A",
    "obtain the generalized logical Pauli operators as operators that commute with all of the stabilizers, but are not in the stabilizer:C(S)/S. Using the 3 isomorphism between the stabilizer group and the latticeΛ, we can show that the Pauli operators coincide with the definition of the symplectic dual latticeΛ∗ Λ∗={u|SΩu∈Z2N}.(9) A potential generator matrix for the symplectic dual lattice is S∗=A−1S,(10) such that we can also write Λ∗={ΩS−1b|b∈Z2N}.(11) As a result, the logical Pauli operators are each associated with one of the det(Λ) = det(A) =d2cosets ofΛ∗/Λ, wheredis the dimension of the finite-dimensional encoded Hilbert space. An important type of unitary operation on oscillators is Gaussian operations, which are generated by Hamiltonians quadratic in mode operators ˆUM= exp/parenleftbigg−i 2ˆξTCˆξ/parenrightbigg , C=CT.(12) We can parametrize this group of unitaries with symplectic matricesM= exp(ΩC), with M∈Sp2N(R). The unitaries ˆUMare representations of the metaplectic group, which is a double cover of the symplectic group. However, it is possible to lift those projective representations to ordinary representations by choosing the right representatives for each M. Doing so, the unitaries respect the homomorphism property ˆUNˆUM=ˆUNM.(13) The action of Gaussian unitaries on mode operators is a linear application of the symplectic representative U† MˆξUM=Mˆξ,(14) where we have an element-wise product on the left and matrix multiplication on the right. This implies the more general relation U† Mf/parenleftigˆξ/parenrightig UM=f/parenleftig Mˆξ/parenrightig ,(15) for any functionf( ˆξ)that can be represented as a power series of mode operators. Any symplectic matrixMcan be written as a a product of two orthogonal matrices and a positive definite diagonal matrix via its Bloch-Messiah decomposition: M=O 2ΓO1,(16) whereOi∈Sp(2N,R)∩O(2N) ∼=U(N)andΓ =D⊕D−1withDis a positive definite diagonal matrix of dimensionN. In this work, we simulate GKP states directly using their Wigner function, defined as W(ξ,ˆρ) =/integraldisplay R2Ndve−i2πξTΩvTr/bracketleftigˆT(v) ˆρ/bracketrightig .(17) 4 This version of the Wigner function is corrected for our specific version of the translation operator and thel=√ 2πscaling for the units ofξ. Consequently, the average of an operator ˆAin phase-space is given by /angbracketleftigˆA/angbracketrightig =Tr/parenleftig ˆρˆA/parenrightig = (2π)2N/integraldisplay R2NdξW(ξ,ˆρ)W/parenleftig ξ,ˆA/parenrightig .(18) When a general gaussian unitary acts on the density matrixU M,λ: ˆρ→UM,λˆρU† M,λ, the Wigner function is modified to W/parenleftig ξ,UM,λˆρU† M,λ/parenrightig =W/parenleftig M−1[ξ−λ],ˆρ/parenrightig ,(19) whereUM,λ=ˆT(λ) ˆUM. An important class of states in harmonic oscillators are Gaussian states. They are the states that are fully described by their first and second moments: µ=/angbracketleftigˆξ/angbracketrightig /√ 2π,Σ jk=1 4π/angbracketleftig/braceleftigˆξj−√ 2πµj,ˆξk−√ 2πµk/bracerightig/angbracketrightig ,(20) where{·,·}is the anticommutator. In phase-space, they are represented by gaussian Wigner functions GΣ,µ(ξ) =exp/parenleftig −1 2(ξ−µ)TΣ−1(ξ−µ)/parenrightig /radicalig (2π)2Ndet(Σ).(21) Finally, wedefine, onabipartitequbitsystemjk, thegeneralizedcontrolledPaulioperation of applying Pauli operatorBon subsystemkif subsystemjis in the−1eigenstate of Pauli operatorAas C(Aj,Bk) =IjIk+AjIk+IjBk−AjBk 2.(22) This symbol is symmetric in the sense thatC(A j,Bk) =C(B k,Aj). Using this notation, a controlledZgate is noted asC(Z 1,Z2)and a controlledXgate with control qubit 1 and target qubit 2 is noted asC(Z 1,X2). 3 Gaussian stabilizer group 3.1 Generalized Stabilizer Groups Qubit stabilizer codes usenqubits to encodek≤nqubits. The codespaceTof these codes is the submanifold of the full Hilbert space/parenleftbigC2/parenrightbignrestricted by the elements of the stabilizer groupScontaining Pauli operators such that T={|ψ⟩:s|ψ⟩=|ψ⟩∀s∈S}.(23) In the usual definition, the stabilizer group of a qubit",
    "asC(Z 1,X2). 3 Gaussian stabilizer group 3.1 Generalized Stabilizer Groups Qubit stabilizer codes usenqubits to encodek≤nqubits. The codespaceTof these codes is the submanifold of the full Hilbert space/parenleftbigC2/parenrightbignrestricted by the elements of the stabilizer groupScontaining Pauli operators such that T={|ψ⟩:s|ψ⟩=|ψ⟩∀s∈S}.(23) In the usual definition, the stabilizer group of a qubit code is generated byn−kcommuting elements, and it completely defines the code [19]. In this definition of the stabilizer group, it is taken to be abelian. However, it is possible to relax this assumption of abelianity and only ask that the stabilizers need to share the2keigenvectors that describeTwith eigenvalue1. This is equivalent to asking that the action of the stabilizers on the codespace commute, but not necessarily the operators themselves: SjSk|ψ⟩=SkSj|ψ⟩∀|ψ⟩∈T̸=⇒[S j,Sk] = 0.(24) 5 The XS [20] and XP [21] formalisms are two examples where qubit codes were constructed from a non-abelian stabilizer group. In general, removing this restriction to abelian groups enables us to define a new stabilizer group that we call the unitary stabilizer : SU={U∈U(2n)|U|ψ⟩=|ψ⟩∀|ψ⟩∈T}.(25) The stabilizer group described in [19] is, by definition, a subgroups ofS U. Similar to the abelian elements, the unitary stabilizers can be used as a resource for stabilization, error mitigation, and potentially decoding. This notion of unitary stabilizer groups can also be used for continuous-variable codes such as the GKP encoding, in which case it becomes of infinite order. It is worth noting that, contrary to the abelian stabilizer, unitary stabilizers might mix error spaces or even entangle those subspaces together, which might be devastating for the preservation of information in the system. With the definition of Eq. (25), we can understand those symmetry operations as encoded identities that are implemented via a non-identity operation on the system. A way to identify such symmetry of a code is to compare the group order of a logical oper- ation with its physical implementation. If they have a mismatching order, then necessarily there will exist a symmetry that will be included inS U. For example, letg∈U(2n)be an operation of orderaon a physical system ofnphysical qubits that represents an encoded operationg∈U/parenleftig 2k/parenrightig of orderbonklogical qubits. Then necessarilyamust be an integer multiple ofbforgto be an adequate representation of g:a=sb,s∈N. This means that grb∈SU∀r∈Zs.(26) An example of such operations for the square GKP code is the logical gate√ Himple- mented via the unitary [18, 22]: Imp/parenleftig/radicalbig H/parenrightig = exp/parenleftbiggiπ 8ˆn2/parenrightbigg .(27) Sinceˆnhas integer eigenvalues, this physical operation has order16, while the underlying logical operation,√ H, has order4. As a result, the four unitaries /braceleftbigg exp/parenleftbiggirπ 2ˆn2/parenrightbigg/bracerightbigg r∈Z4,(28) implement a logical identity on the square GKP code. For infinite-dimensional Hilbert spaces, the physical implementation of a logical operation might be of infinite order, re- sulting in the inclusion of an infinite subgroup inS U. There might even exist stabilizing operations that do not correspond to powers of non-trivial logical operations. As a whole, the rich structure of the unitary stabilizer group makes it impractical to try to find every element inS U. Following this thread of ideas, we restrict the scope of this paper to grid codes. We will",
    "operations that do not correspond to powers of non-trivial logical operations. As a whole, the rich structure of the unitary stabilizer group makes it impractical to try to find every element inS U. Following this thread of ideas, we restrict the scope of this paper to grid codes. We will also only be interested in a subgroup that is more easily implementable,i.e. Gaussian operations. For qubit stabilizer codes, the restriction of the unitary stabilizer group to Clifford operations has been studied [23, 24] to optimize the implementation of logical Clifford operations. This work extends this notion to GKP codes. 3.2 Gaussian Stabilizer Group The elements of any generalized stabilizer group on grid codes need to share a specific property: they need to stabilize the Pauli subgridsP j⊂Λ∗individually: Pj= Λ +pjpj∈Λ∗,(29) 6 with an indexjfor every logical Pauli string. By definition,P 0isΛ. This gives a new definition of the group as the intersection of all automorphisms of these subgrids SU=/intersectiondisplay jAut(Pj)⊂Aut(Λ∗).(30) For grid codes, an important subgroup ofS Uis the Gaussian stabilizer group, which we define as the intersection of the unitary stabilizer group and the Gaussian unitaries SG=SU∩{UM|M∈Sp2N(R)}.(31) Since any Gaussian unitary acts as an affine transformation on phase space, and stabilizers inSGmust be logical operations of the code, we know that each element ofS Gadmits the decomposition [25] SG⊂AutS ∞(Λ∗) =AutS(Λ∗)⋉Λ∗.(32) Such affine transformations are characterized by two transformations: a fixed point sym- plectic transformationM∈AutS(Λ∗)and a translation by a vector ofλ∈Λ∗. We denote such transformations byL M,λwith its application LM,λ(u) =Mu+λ.(33) With respect to the condition in Eq. (30), these morphisms describe an element ofS G when LM,λ(Pj) =Pj∀j.(34) Expanding the restrictriction in terms of the original latticeP 0moved by a vector of the dual latticepj, we obtain a much simpler condition onM: LM,λ(Pj) =LM,λ(P0) +Mpj=P 0+pj,(35) (M−I)pj∈Λ∀j.(36) Using both the lattice and the dual lattice definition in terms of their generator matrix (S andS∗), we conclude that elements ofS Gmust have a fixed-point transformation of the form M=ST(XA+I)S−T,(37) whereX∈Mat 2N(Z)is a general matrix of integers and(XA+I)∈SL 2N(Z)(see Sect. A). The matrixMis a valid solution only if it is also symplectic, which is not implied by Eq. (37). Enforcing the symplectic structure toMreturns an equation forX XAXT−/parenleftig X−XT/parenrightig = 0,(38) withAthe symplectic Gram matrix that defines the lattice. From [10, 26], we know that for every integrally symplectic matrixA=SΩST, there is a change of basisR∈SL 2N(Z) that transformsSandAas SD=RS, A D=RART= Ω 2⊗D,(39) such thatDis a diagonal matrix of natural numbers that fix the type of lattice. SinceA andADdescribe the same latticeΛ, the transformationMmust be valid for both. As a result, if the pair(X D,AD)is a solution to Eq. (38), then so must be/parenleftig RTXDR,A/parenrightig . As a result, we only have to solve the equation XDADXT D−/parenleftig XD−XT D/parenrightig = 0(40) 7 which is simpler sinceA Dis skew-symmetric with onlyNindependant non-zero elements. The solutions of Eq. (40) form a group with a product◦defined as XD◦YD=XD+YD+XDADYD,(41) withXD,YDsolutions to Eq. (40). The group product for solutions in Eq. (41) is also the group product for solutions in a non-canonical basis, such as",
    "0(40) 7 which is simpler sinceA Dis skew-symmetric with onlyNindependant non-zero elements. The solutions of Eq. (40) form a group with a product◦defined as XD◦YD=XD+YD+XDADYD,(41) withXD,YDsolutions to Eq. (40). The group product for solutions in Eq. (41) is also the group product for solutions in a non-canonical basis, such as the solutions of Eq. (38). To fully describe the transformationsM, we now proceed to find the generators of this group of solutions using the generators of the symplectic algebrasp(2N,R). Looking at Eq. (37), we can deduce thatXAmust be similar in structure to an element that is a small deviation from the identity, which also respects the symplectic property. This is equivalent to saying thatXAhas the same structure as an element of the symplectic algebrasp(2N,R). A basis forsp(2N,R)can be chosen to be the union of two sets. The first set contains symmetric matrices Fj,k=Ej,k+Ek,j, Fj,j=Ej,j,(42) and the second contains skew-symmetric matrices Gj,k=Ej,k−Ek,j,(43) withEj,kthe matrix with1at position(j,k)and0elsewhere. We use those basis elements to search for solutions of Eq. (40). Starting with the symmetric set, we fix the solution toXD=αFj,kwithk≥jand try to solve forα∈Z. This type of matrix is a non-zero solution of Eq. (40) only if AD,j,k = 0.(44) This condition is validated for all values ofαand all pairs of indices(j,k), except for combinations of the form(j,k) = (j,N+j). We also find that the product rule in Eq. (41) is simplified to α1Fj,k◦α2Fj,k= (α 1+α 2)Fj,k (45) when restricted to this infinite subgroup of solutions. This means that solutionsF j,k generate all other solutions of the formαF j,k, α∈Zvia products with itself. By counting the number of valid(j,k)pairs, we obtain2N2generators of this type. Moving on to skew-symmetric solutions, we fixX D=βGj,kwithβ∈Z. This matrix is a solution only if 2−βAD,j,k = 0.(46) Because of the structure ofA D, this can only be validated for pairs of indices such that(j,k) = (j,N+j), which complement the symmetric set of solutions. Addition- ally, the relation of Eq. (46) can also only be validated if the matrixA Dcontains elements AD,j,k∈{1,2}. As such, we get two types of potential solutions:(β= 1,A D,j,k = 2)and (β= 2,A D,j,k = 1). Both correspond to an involution operation such that βGj,k◦βGj,k= 0.(47) Futhermore, only whenA D,j,k = 1, we get an order four solution:X D=Gj,k+Fj,j+Fk,k that squares to the solution of Eq. (46). In total, we have between2N2and2N2+N generators of solutions depending on the number of diagonal elements ofDthat are either 1or2. This corresponds to the maximum number of generators possible, which means that we found all solutions to Eq. (40). 8 Now that the fixed-point part of the transformationMis determined, it only remains to fixλto fully parametrize the transformationL M,λ. OnceMis obtained, it is easy to compute its action on the Pauli subgrids. MP 0=Pj.(48) Then,λcan be chosen as any vector inΛ∗such that λ+Pj=P 0,(49) fixingLM,λup to a translation stabilizer of the code. In the end, for each generator of solutionX kof Eq. (38), we get a gaussian stabilizer group generatorU Mk,λk, that implements the transformationsL Mk,λk. We can now write the Gaussian stabilizer group as the group generated by the2Ntranslation stabilizers",
    "that λ+Pj=P 0,(49) fixingLM,λup to a translation stabilizer of the code. In the end, for each generator of solutionX kof Eq. (38), we get a gaussian stabilizer group generatorU Mk,λk, that implements the transformationsL Mk,λk. We can now write the Gaussian stabilizer group as the group generated by the2Ntranslation stabilizers (indexed byj) and the2N2+m Gaussian stabilizer generatorsU Mk,λk SG=/angbracketleftigˆT(sj),UMk,λk/angbracketrightig (50) withmthe number of entries inDthat are either1or2. 3.3 Square GKP Gaussians Stabilizer We now proceed to give an example of this group for the single-mode square GKP code and how it is related to the encoded Clifford group. We then construct the same group but for the combination of two square GKP codes before generalizing toNsquare GKP codes. For the single mode case, the generator matrix isS=√ 2I2and the symplectic Gram matrix is A= 2Ω 2,(51) which is already in the canonical form. To parametrize the Gaussian stabilizer group, we are looking for all symplectic matrices of the form M= 2XΩ 2+I.(52) Following the analysis of the last section, we find three generators for the solutions of the Eq. (38). They are XH2=/bracketleftigg 0 1 −1 0/bracketrightigg , XQ2=/bracketleftigg 1 0 0 0/bracketrightigg , XP2=/bracketleftigg 0 0 0 1/bracketrightigg ,(53) with the corresponding symplectic matrices MH2=/bracketleftigg −1 0 0−1/bracketrightigg , MQ2=/bracketleftigg 1 2 0 1/bracketrightigg , MP2=/bracketleftigg 1 0 −2 1/bracketrightigg .(54) We indexed them asH2,Q2andP2because of their logical action on the code, with Qdenoting the phase gate in the logicalXbasis andPthe phase gate in the logicalZ basis. The transformations in Eq. (54) implement the square of the logical operators H,√ Xand√ Z, respectively. From each symplectic matrix of Eq. (54), the corresponding unitary operator that implement it are obtained by solving Eq. (12), which in this case yieldH2= exp{−iπˆn}, Q2= exp/braceleftbig−iˆp2/bracerightbigandP2= exp/braceleftbig−iˆq2/bracerightbig, respectively. It now only remains to fix the translation part of the affine transformations. BecauseM Q2is 9 equivalent to apply a Q2operation, it maps the gridP 0toPx. The result is that the affine transformationL MQ2,λ∈Px=XQ2is a generator of the gaussian stabilizer group. Similary, the transformationL MP2,λ∈Pz=ZP2is also a generator. Finally, we find that H2is itself a generator. The Gaussian stabilizer group of the single-mode square GKP code is S□=/angbracketleftig X2,Z2,XQ2,ZP2,H2/angbracketrightig .(55) We now move on to the combination of two square GKP codes. In this case, the Gaussian stabilizer group inherit two copies of the Gaussian stabilizer group described previously, one for each mode. There are still four new generators to find out of the ten in total. The symplectic Gram matrix now is2Ω 4, and we are looking for symplectic matrices of the form M= 2XΩ 4+I.(56) The four missing generators are related to the solutionsX=F j,k,k≥jthat are not on the diagonal of any single block, given byF 1,2,F2,3,F3,4andF 1,4. From those four solutions, we obtain the following four symplectic matrices M1= 1 0 0 2 0 1 2 0 0 0 1 0 0 0 0 1 , M 2= 1 0 0 0 −2 1 0 0 0 0 1 2 0 0 0 1 ,(57) M3= 1 0 0 0 0 1 0 0 0−2",
    "four symplectic matrices M1= 1 0 0 2 0 1 2 0 0 0 1 0 0 0 0 1 , M 2= 1 0 0 0 −2 1 0 0 0 0 1 2 0 0 0 1 ,(57) M3= 1 0 0 0 0 1 0 0 0−2 1 0 −2 0 0 1 ,andM 4= 1−2 0 0 0 1 0 0 0 0 1 0 0 0 2 1 .(58) TheiractiononthePaulioperators Xj= exp (−iˆp j√π)andZj= exp (iˆq j√π),aregivenby the squares of the encoded controlled Pauli operators C(X 1,X2),C(Z 1,X2),C(Z 1,Z2) andC(X 1,Z2), in order fromM 1toM 4, respectively. They are implemented by the unitaries C(Xj,Xk)2= exp (2iˆp jˆpk)C(Zj,Xk)2= exp (2iˆq jˆpk)C(Zj,Zk)2= exp (−2iˆq jˆqk). (59) Any encoded generalized controlled Pauli gate is an order two logical gate, such that C(A,B)2is in the Gaussian stabilizer group. As a result, we can write the full Gaussian stabilizer group as generated by the two sets of single-mode GKP Gaussian stabilizer gen- erators and those four additional two-mode generators. Since the full group of symplectic operations is generated by two-body interactions, the Gaussian stabilizer group overN single-mode square GKP is found as S□⊗N=/angbracketleftig X2 j,Z2 j,XjQ2 j,ZjP2 j,H2 j,C(Xj,Xk)2,C(Zj,Xk)2,C(Zj,Zk)2/angbracketrightig (60) withj,k∈{1...N}andj̸=k. Moreover, since this decomposition is based on the canon- ical form of the Gram matrixA, any combination of arbitrary one-mode GKP qubits leads to a Gaussian stabilizer group with the same structure and a very similar generator decomposition. 10 <latexit sha1_base64=\"w1nXAp2jB4mVAOMgQqeAOByYTm0=\">AAACUXicbVBNa9tAEB0pn7XTNGmOvYiYQkrBSCUkOQZ66SmkUNsBSZjVemQv3l2J3VGCEfoRubY/q6f8lNyydgxOnAwMPN57w8y8rJTCUhg+eP7G5tb2zu6HVnvv4/6ng8PPfVtUhmOPF7IwNxmzKIXGHgmSeFMaZCqTOMimP+f64BaNFYX+Q7MSU8XGWuSCM3LUIJki1d+b4UEn7IaLCt6CaAk6sKzr4aF3mowKXinUxCWzNo7CktKaGRJcYtNKKosl41M2xthBzRTatF7c2wRfHTMK8sK41hQs2JcTNVPWzlTmnIrRxK5rc/I9La4ov0hrocuKUPPnRXklAyqC+fPBSBjkJGcOMG6EuzXgE2YYJxfRqy2ZYS4a94fGO14oxfSoTsqyiaO0TiTmdFJ3oiYxYjyhb2u2LFvZ4pUtbVou52g91beg/6MbnXXPfp92Lq+Wie/CFziGE4jgHC7hF1xDDzhM4R7+wj/vv/fog+8/W31vOXMEr8pvPwHGebOv</latexit>|+→<latexit sha1_base64=\"dIlf5ZKOcOVV5Rp4hF5xZoFeDvE=\">AAACbnicbVBNixNBEO2MX2v8yip4EXHYIMRLmJFl9bjgxZOssNldmBlCTU9Npk13T9Ndo4Rm7v4ar/pX/Bf+BDvZwLpZC5p+vPeKqnqlkcJRkvweRLdu37l7b+/+8MHDR4+fjPafnrm2sxxnvJWtvSjBoRQaZyRI4oWxCKqUeF4uP6z1869onWj1Ka0MFgoWWtSCAwVqPjrIGyB/2ufG+LxsZeVWKnw+B2ka6Odf+uF8NE6myabimyDdgjHb1sl8f3CYVy3vFGriEpzL0sRQ4cGS4BL7Yd45NMCXsMAsQA0KXeE3x/Tx68BUcd3a8DTFG/bfDg/KrZcMTgXUuF1tTf5Pyzqq3xdeaNMRan45qO5kTG28TiauhEVOchUAcCvCrjFvwAKnkN+1KaWFJVK4Q+M33ioFuvIhwD5LC59LrGnix2mfW7Fo6M2OrSyvbNmVrdjknO6mehOcvZ2mR9Ojz4fj40/bxPfYC3bAJixl79gx+8hO2Ixx9p39YD/Zr8Gf6Hn0Mnp1aY0G255n7FpFk78TUr8F</latexit>ˆT(ωj)<latexit sha1_base64=\"dIlf5ZKOcOVV5Rp4hF5xZoFeDvE=\">AAACbnicbVBNixNBEO2MX2v8yip4EXHYIMRLmJFl9bjgxZOssNldmBlCTU9Npk13T9Ndo4Rm7v4ar/pX/Bf+BDvZwLpZC5p+vPeKqnqlkcJRkvweRLdu37l7b+/+8MHDR4+fjPafnrm2sxxnvJWtvSjBoRQaZyRI4oWxCKqUeF4uP6z1869onWj1Ka0MFgoWWtSCAwVqPjrIGyB/2ufG+LxsZeVWKnw+B2ka6Odf+uF8NE6myabimyDdgjHb1sl8f3CYVy3vFGriEpzL0sRQ4cGS4BL7Yd45NMCXsMAsQA0KXeE3x/Tx68BUcd3a8DTFG/bfDg/KrZcMTgXUuF1tTf5Pyzqq3xdeaNMRan45qO5kTG28TiauhEVOchUAcCvCrjFvwAKnkN+1KaWFJVK4Q+M33ioFuvIhwD5LC59LrGnix2mfW7Fo6M2OrSyvbNmVrdjknO6mehOcvZ2mR9Ojz4fj40/bxPfYC3bAJixl79gx+8hO2Ixx9p39YD/Zr8Gf6Hn0Mnp1aY0G255n7FpFk78TUr8F</latexit>ˆT(ωj) <latexit sha1_base64=\"2BOl4SG9wenS/UQDpYUL9sGrP+g=\">AAACbXicbVDbbtNAEN24XEq4pSCeQMgQIcpLZKOq8FiJF55QkZq2km1F4/U42WYv1u4YFK383K/hlX5Lv4JfYJNGKk0ZabVH55zRzJyykcJRklz2oq07d+/d337Qf/jo8ZOng51nx860luOYG2nsaQkOpdA4JkESTxuLoEqJJ+X8y1I/+YHWCaOPaNFgoWCqRS04UKAmgzf5DMgfdXnT+Lw0snILFb6AkaCbnHX9yWCYjJJVxbdBugZDtq7DyU5vL68MbxVq4hKcy9KkocKDJcEldv28ddgAn8MUswA1KHSFX93Sxe8CU8W1seFpilfsvx0elFvuGJwKaOY2tSX5Py1rqf5ceKGbllDzq0F1K2My8TKYuBIWOclFAMCtCLvGfAYWOIX4bkwpLcyRwh0af3KjFOjKh/y6LC18LrGmXT9Mu9yK6Yw+bNjK8tqWXduKVc7pZqq3wfHHUbo/2v++Nzz4tk58m71kb9kuS9kndsC+skM2Zpyds1/sN7vo/YleRK+i11fWqLfuec5uVPT+LxYzvpE=</latexit>ˆT/parenleftbigωj/parenrightbig <latexit sha1_base64=\"HhRXeuz3UoZP4jROsFiVlhaiAeQ=\">AAACinicbVBNb9NAEN2YrxIKTeHIxSJCKgciu6oKCAlVAiQ4UVDTVrKNNV6PkyW7a2t3DAor/xt+DVe48G/YpJFKUkZa7dN7bzQzr2iksBRFf3rBtes3bt7aut2/s3333s5g9/6prVvDccxrWZvzAixKoXFMgiSeNwZBFRLPitnrhX72FY0VtT6heYOZgokWleBAnsoHr9IpkPvU5d/TpnFPZVrUsrRz5T+XFkjQ5V8+n6QfFE5gTVNtl7/t8sEwGkXLCq+CeAWGbFXH+W7vIC1r3irUxCVYm8RRQ5kDQ4JL7Pppa7EBPoMJJh5qUGgztzy0Cx97pgyr2vinKVyy/3Y4UHaxoHcqoKnd1Bbk/7Skpep55oRuWkLNLwZVrQypDhephaUwyEnOPQBuhN815FMwwMlnuzalMDBD8ndo/MZrpUCXzkfbJXHmUokV7blh3KVGTKb0ZMNWFJe25NKWdX2fc7yZ6lVwuj+KD0eHHw+GR+9XiW+xh+wR22Mxe8aO2Dt2zMaMsx/sJ/vFfgfbwX7wInh5YQ16q54HbK2CN38Bx2HKeQ==</latexit>ˆRz/parenleftig→lωTj!µE/parenrightig<latexit sha1_base64=\"HhRXeuz3UoZP4jROsFiVlhaiAeQ=\">AAACinicbVBNb9NAEN2YrxIKTeHIxSJCKgciu6oKCAlVAiQ4UVDTVrKNNV6PkyW7a2t3DAor/xt+DVe48G/YpJFKUkZa7dN7bzQzr2iksBRFf3rBtes3bt7aut2/s3333s5g9/6prVvDccxrWZvzAixKoXFMgiSeNwZBFRLPitnrhX72FY0VtT6heYOZgokWleBAnsoHr9IpkPvU5d/TpnFPZVrUsrRz5T+XFkjQ5V8+n6QfFE5gTVNtl7/t8sEwGkXLCq+CeAWGbFXH+W7vIC1r3irUxCVYm8RRQ5kDQ4JL7Pppa7EBPoMJJh5qUGgztzy0Cx97pgyr2vinKVyy/3Y4UHaxoHcqoKnd1Bbk/7Skpep55oRuWkLNLwZVrQypDhephaUwyEnOPQBuhN815FMwwMlnuzalMDBD8ndo/MZrpUCXzkfbJXHmUokV7blh3KVGTKb0ZMNWFJe25NKWdX2fc7yZ6lVwuj+KD0eHHw+GR+9XiW+xh+wR22Mxe8aO2Dt2zMaMsx/sJ/vFfgfbwX7wInh5YQ16q54HbK2CN38Bx2HKeQ==</latexit>ˆRz/parenleftig→lωTj!µE/parenrightig <latexit sha1_base64=\"omjyjV4ZrOMm+rzIyU9xqBe+Py0=\">AAACi3icbVBNb9NAEN2YrxIopHDkYhEhlQORXaqCEBKVUCU4UVDTVrKNNd6M4yW7a2t3DAor/xx+DVc48G/YpJFKUkZa7dN7bzQzr2iksBRFf3rBtes3bt7aut2/c3f73v3BzoNTW7eG45jXsjbnBViUQuOYBEk8bwyCKiSeFbO3C/3sKxoran1C8wYzBVMtSsGBPJUP3qQVkPvU5d/TpnHPZFrUcmLnyn8uBdlU0OVfPp+kHxROYU1UbZcfdflgGI2iZYVXQbwCQ7aq43ynt59Oat4q1MQlWJvEUUOZA0OCS+z6aWuxAT6DKSYealBoM7e8tAufeGYSlrXxT1O4ZP/tcKDsYkHvVECV3dQW5P+0pKXyZeaEblpCzS8Gla0MqQ4XsYUTYZCTnHsA3Ai/a8grMMDJh7s2pTAwQ/J3aPzGa6VAT5zPtkvizKUSS9p1w7hLjZhW9HTDVhSXtuTSlnV9n3O8mepVcLo3ig9GBx/3h4fvV4lvsUfsMdtlMXvBDtk7dszGjLMf7Cf7xX4H28Hz4FXw+sIa9FY9D9laBUd/AdCEyu0=</latexit>ˆRz/parenleftbig→lωTj!µE/parenrightbig<latexit sha1_base64=\"omjyjV4ZrOMm+rzIyU9xqBe+Py0=\">AAACi3icbVBNb9NAEN2YrxIopHDkYhEhlQORXaqCEBKVUCU4UVDTVrKNNd6M4yW7a2t3DAor/xx+DVc48G/YpJFKUkZa7dN7bzQzr2iksBRFf3rBtes3bt7aut2/c3f73v3BzoNTW7eG45jXsjbnBViUQuOYBEk8bwyCKiSeFbO3C/3sKxoran1C8wYzBVMtSsGBPJUP3qQVkPvU5d/TpnHPZFrUcmLnyn8uBdlU0OVfPp+kHxROYU1UbZcfdflgGI2iZYVXQbwCQ7aq43ynt59Oat4q1MQlWJvEUUOZA0OCS+z6aWuxAT6DKSYealBoM7e8tAufeGYSlrXxT1O4ZP/tcKDsYkHvVECV3dQW5P+0pKXyZeaEblpCzS8Gla0MqQ4XsYUTYZCTnHsA3Ai/a8grMMDJh7s2pTAwQ/J3aPzGa6VAT5zPtkvizKUSS9p1w7hLjZhW9HTDVhSXtuTSlnV9n3O8mepVcLo3ig9GBx/3h4fvV4lvsUfsMdtlMXvBDtk7dszGjLMf7Cf7xX4H28Hz4FXw+sIa9FY9D9laBUd/AdCEyu0=</latexit>ˆRz/parenleftbig→lωTj!µE/parenrightbig <latexit sha1_base64=\"Df9WX+hjNUFbZ5UqczApnykHEqI=\">AAACX3icbVDBTttAFNyYUmhKIZRTxcVqVIleUhsh6BGpF7jRigCSbUXPm+dkld31aveZNrL8Lb3CJ3HkT9iESEBgpJVGM/P03k5upHAURXetYOXd6vu19Q/tjxufNrc6258vXFlZjn1eytJe5eBQCo19EiTxylgElUu8zCe/Zv7lNVonSn1OU4OZgpEWheBAXhp0dtIxUP2nGfxLjalTI37sN4NON+pFc4SvSbwgXbbA2WC7dZAOS14p1MQlOJfEkaGsBkuCS2zaaeXQAJ/ACBNPNSh0WT2/vgm/eWUYFqX1T1M4V59P1KCcm6rcJxXQ2C17M/EtL6mo+JnVQpuKUPPHRUUlQyrDWRXhUFjkJKeeALfC3xryMVjg5At7sSW3MEHy/9D4l5dKgR76rkyTxFmdSixor+7GTWrFaEzfl2J5/hRLnmJZ0/Y9x8utviYX+734sHf4+6B7fLpofJ3tsq9sj8XsiB2zE3bG+oyzKfvPbtht6z5YCzaDzmM0aC1mdtgLBF8eAC4FuBU=</latexit>ˆRx(ω/2)<latexit sha1_base64=\"Df9WX+hjNUFbZ5UqczApnykHEqI=\">AAACX3icbVDBTttAFNyYUmhKIZRTxcVqVIleUhsh6BGpF7jRigCSbUXPm+dkld31aveZNrL8Lb3CJ3HkT9iESEBgpJVGM/P03k5upHAURXetYOXd6vu19Q/tjxufNrc6258vXFlZjn1eytJe5eBQCo19EiTxylgElUu8zCe/Zv7lNVonSn1OU4OZgpEWheBAXhp0dtIxUP2nGfxLjalTI37sN4NON+pFc4SvSbwgXbbA2WC7dZAOS14p1MQlOJfEkaGsBkuCS2zaaeXQAJ/ACBNPNSh0WT2/vgm/eWUYFqX1T1M4V59P1KCcm6rcJxXQ2C17M/EtL6mo+JnVQpuKUPPHRUUlQyrDWRXhUFjkJKeeALfC3xryMVjg5At7sSW3MEHy/9D4l5dKgR76rkyTxFmdSixor+7GTWrFaEzfl2J5/hRLnmJZ0/Y9x8utviYX+734sHf4+6B7fLpofJ3tsq9sj8XsiB2zE3bG+oyzKfvPbtht6z5YCzaDzmM0aC1mdtgLBF8eAC4FuBU=</latexit>ˆRx(ω/2) <latexit sha1_base64=\"XUSTGO51H21luVc/3/hcDqwp8nY=\">AAAC53icbVFNbxMxEPUuXyV8pXDkYhEhyqHRLqoKl0qVuMAhooikrbTerGa93o2J7V3Z3qLI2t/ADSFx4mfxb3DSSG2TjmTN05s3Y/tN3ghubBT9C8I7d+/df7DzsPfo8ZOnz/q7z09N3WrKJrQWtT7PwTDBFZtYbgU7bzQDmQt2ls8/LutnF0wbXquxXTQslVApXnIK1lNZ/w/Ja1GYhfTJERDNDLrsOz7CpNRA3T4eEcPVjDSNI994JSGLpm4/7rrRdEy+SFYBvj7B+ObObTLT8cg3jTti4fZRy7Q1ppf1B9EwWgXeBvEaDNA6TrLd4IAUNW0lU5YKMCaJo8amDrTlVLCuR1rDGqBzqFjioQLJTOpWLnb4tWcKXNbaH2Xxir3e4UCa5fu8UoKdmc3akrytlrS2/JA6rprWMkUvLypbgW2NlyvBBdeMWrHwAKjm/q2YzsDbb/3ibtySa5gz6/+h2A9aSwmqcN7PLolTRwQr7Z4beCc1r2b27YYsz69kyZUsXfkcb7q6DU7fDePD4eHXg8Hx57XjO+gleoX2UIzeo2P0CZ2gCaJBELwJoiAOefgz/BX+vpSGwbrnBboR4d//85Ls0g==</latexit>ωj=→Msinh/parenleftbig!→10/parenrightbigMT”sjsTjM→Ttanh/parenleftbig!→10/parenrightbigM→1sj<latexit sha1_base64=\"njE6g4mli2+lMIf4N0OzKSj88rw=\">AAAC43icdVFdaxQxFM2MX3X92uqjL8FBqGCXmVKqL0LBF30oVNxtC5PpkMne2U03kwxJRlnC/ALfRPDJH+aPEcxMF9ru6oWQw7nnfuSkqAU3No5/B+Gt23fu3tu6P3jw8NHjJ8PtpydGNZrBhCmh9FlBDQguYWK5FXBWa6BVIeC0WLzv8qdfQBuu5Ngua8gqOpO85IxaT+XDn6RQYmqWlb8cKcDSNr/A7zApNWVuDx8Rpsyc1LUjn/msonl87naTtj3qL3y92vjK1q0z5+NOOm6JpfK/fTbaDPJhFI/iPvAmSFYgQqs4zreDfTJVrKlAWiaoMWkS1zZzVFvOBLQD0hioKVvQGaQeSlqByVzvYItfemaKS6X9kRb37PUKRyvT7eeVFbVzs57ryH/l0saWbzPHZd1YkOxyUNkIbBXuvgNPuQZmxdIDyjT3u2I2p9576z/txpRC0wVY/w4JX5mqKiqnzvvZpknmiIDS7rjIO6n5bG5frcmK4kqWXsmy3udk3dVNcLI3Sg5GB5/2o8OPK8e30HP0Au2gBL1Bh+gDOkYTxNCfIApeB7shhN/C7+GPS2kYrGqeoRsR/voLYOjr/A==</latexit>ωj=2Mcosh/parenleftbig!→10/parenrightbigM→1sjsTjM→Ttanh/parenleftbig!→10/parenrightbigM→1sjFigure 1:Finite-energy GKP state stabilization.Autonomous sBs stabilization circuit for a GKP state with envelope described by the covariance matrixΣ E=MΣ 0MTand positionµE. The protocol uses engineered cooling of a GKP onNmodes (represented by three wires) using a 2-level system as an ancilla (bottom wire) that is discarded at the end. The full stabilization is the result of cycling over all the stabilizer generators{s j}of the code. 4 Noise protection of finite energy GKP codes The construction of the Gaussian stabilizer group in Sects. 3.2 and 3.3 was tailored for GKP codes that span infinitely in phase space. In the following sections, we are interested in using this group as a resource to increase the performance of gate-based computation with a finite-energy GKP encoding. We show how a non-abelian stabilizer group on the infinite energy code becomes a logical isometry group on finite energy codewords. Based on arguments related to the noise channels, we propose optimization metrics to compare different implementations of Clifford gates. 4.1 Finite-energy GKP and Gaussian stabilizer A logical state of the infinite energy GKP code defined by the generator matrixSis noted |ΨS⟩. We construct a finite-energy logical state from|Ψ S⟩by acting with a fock type damping operatorEon it: E(ΣE,µE)|ΨS⟩∝exp/parenleftbigg −1 2/bracketleftigˆξ−µE/bracketrightigTΣ−1 E/bracketleftigˆξ−µE/bracketrightig/parenrightbigg |ΨS⟩.(61) This damping operator can be understood as a Gaussian envelope described by a mean positionµEand a covariance matrixΣ E. This state can be stabilized by a sequence of measurements of all normalized stabilizers ˆTΣE,µE(sj) =E(ΣE,µE)ˆT(sj)E(ΣE,µE)−1.(62) Another way of achieving stabilization of this state is by engineering an oscillator-bath interaction",
    "|ΨS⟩.(61) This damping operator can be understood as a Gaussian envelope described by a mean positionµEand a covariance matrixΣ E. This state can be stabilized by a sequence of measurements of all normalized stabilizers ˆTΣE,µE(sj) =E(ΣE,µE)ˆT(sj)E(ΣE,µE)−1.(62) Another way of achieving stabilization of this state is by engineering an oscillator-bath interaction that cools down the oscillator’s system toward the+1eigenspace of each ˆTΣE,µE(sj). One such protocol, called sBs [7, 14], was described in Ref. [18] for a mul- timode GKP code with an isometric envelope. The sBs protocol can be generalized to accommodate a more general envelopeE(Σ E,µE)presented here. The circuit that imple- ments it, using only controlled displacements and qubit rotations, is presented in Fig. 1 and the full derivation is included in Sect. B. In an experimental setup, an initialization algorithm that prepares a logical state|Ψ S,Σ,µ⟩∝E(Σ E,µE)|ΨS⟩with an envelope that is centred and distributed equally in the quadratures of each mode is preferred, as we show in the following sections. In other words, at the beginning of a computation, the ideal envelope is described by the parameters Σ0=ε−1⊕ε−1µE=0(63) whereεis a diagonal matrix of dimensionN×Nwith elementsε jon its diagonal that describe the distribution of modej. At initialization time, the envelope thus takes the 11 form E(Σ 0,0) = exp −/summationdisplay jεjˆnj .(64) The smaller the value ofε jis, the closer the code is to its infinite energy counterpart. In the process of stabilizing the GKP codespace in an actual device, there exists an optimal valueεj, limited by the amount of amplitude damping or other noises. For a unitaryU that implements a general logical operator on the infinite energy codespaceU|Ψ S⟩=|ΦS⟩, the application of the same operator on a finite-energy state is equivalent to applying the gate perfectly on the logical state and modifying the envelope: UE(Σ,µ)|Ψ S⟩=/parenleftig UE(Σ,µ)U†/parenrightig U|ΨS⟩=E′(Σ,µ,U)|Φ S⟩.(65) For a general unitaryU, the new envelopeE′is not Gaussian. However, in the case that Uis a Gaussian unitary indexed by the symplectic matrixMfollowed by a translation in phase space byλ,U M,λ, the new envelopeE′remains Gaussian and is computed using Eq. (15): UM,λ:E(Σ,µ)→E/parenleftig MΣMT,Mµ+λ/parenrightig .(66) As a result, no logical information is transferred to the envelope during a Clifford cir- cuit computation since Clifford operations are implemented via Gaussian unitaries, . At each step, the logical information is contained only within the underlying infinite energy grid state|Ψ S⟩or|ΦS⟩. If the transformationU M,λdescribes a symmetry of the code, UM,λ|ΨS⟩=|ΨS⟩, the initial and final states both contain the same logical information, even if different envelopes describe the states. They are physically different, but logically equivalent. We’ve seen how to parametrize this set of logically equivalent states in Sect. 3. The set of Gaussian operations that are also isometries of a GKP code is the definition of the Gaussian stabilizer group of Eq. (50): UM,λE(Σ,µ)|Ψ S⟩=E/parenleftig MΣMT,Mµ+λ/parenrightig |ΨS⟩ ∀UM,λ∈SG.(67) In the following, we show that the existence of an optimal state, and therefore, of an optimal circuit, is highly dependent on the noise model. 4.2 Noise model and state representative optimization A quantum circuit defined by a sequence of gates{V k}and initial logical state|Ψ 0⟩can, equivalently,",
    "MΣMT,Mµ+λ/parenrightig |ΨS⟩ ∀UM,λ∈SG.(67) In the following, we show that the existence of an optimal state, and therefore, of an optimal circuit, is highly dependent on the noise model. 4.2 Noise model and state representative optimization A quantum circuit defined by a sequence of gates{V k}and initial logical state|Ψ 0⟩can, equivalently, be fully caracterised by a sequence{|Ψ k⟩}of states : ...Vk−1−−−→|Ψ k−1⟩Vk−→|Ψk⟩Vk+1−−−→...(68) This dual description of a circuit can be used as a tool to optimize how the sequence/braceleftig Vk/bracerightig is implemented, based on the properties of the state sequence. During a computation, some intermediate states might be more prone to errors, making it favourable to choose an alternative circuit implementation and hence reducing the probability of having an error. In the context of quantum error correction, we aim to implement an encoded circuit/parenleftig/vextendsingle/vextendsingle/vextendsingleΨ0/angbracketrightig ,/braceleftig Vk/bracerightig/parenrightig onto a physical system : ...Imp(Vk−1)−−−−−−−→/vextendsingle/vextendsingle/vextendsingleImp/parenleftig Ψk−1/parenrightig/angbracketrightigImp(Vk)−−−−−−→/vextendsingle/vextendsingle/vextendsingleImp/parenleftig Ψk/parenrightig/angbracketrightigImp(Vk+1)−−−−−−−→...(69) 12 An explicit physical implementation (Imp) is called a compilation strategy. In the typical quantum error correction code, the implementation of a codeword Imp/parenleftig Ψk/parenrightig is unique, and so, only the gate compilation needs to be optimized. As presented in the last section, the case of GKP codes is different since different physical states with different envelopes describe the same logical information. This additional degree of freedom can be used to reduce the effect of noise on the logical information during the computation by choosing the logical states that are less affected by noise at each step. The optimization over all the different implementations can then be done in both the gates compilation picture or the states compilation picture. Since the best implementation is noise-dependent, we need to define a noise model and its effect on the GKP codewords as a function of the parameters of the envelopeΣ EandµEin order to find an optimization criterion. There are two main error channels for bosonic codes in harmonic modes. The more promi- nent one is bosonic lossN L[γ]with its Kraus representation [27]: NL[γ] (ρ) =∞/summationdisplay k=0ˆLkˆρˆL† k, ˆLk=/radicaligg γk k!(1−γ)ˆn/2ˆak.(70) Among other transformations, the main action of this channel on functions of phase-space is a radial contraction of every feature toward the origin by a factor of√γ, displacing by an amount√γrfeatures at radiusr. The dephasing channel is the second most impactful noise channel on bosonic modes, and is represented as [12] ND[γϕ] (ρ) =1/radicalbig2πγϕ/integraldisplay Rdϕe−ϕ2/2γϕeiϕˆnˆρe−iϕˆn.(71) Its action is to smear phase-space functions in the angular direction, which can also be interpreted as a rotation in phase-space by a random angle sampled from a normal dis- tribution. On average, this channel rotates the Wigner function of a state by an angle of amplitude/radicalbig 2/πγϕ. For a small dephasing rateγ ϕ, this induces a displacement of/radicalbig 2/πγϕrfor a feature positioned at radiusrin phase-space. Because their action are in orthogonal directions, the pure loss and dephasing channel commute [27] and, therefore, the general noise channel can be described as a composition of both: NLD[γ,γϕ] =NL[γ]◦ND[γϕ] =ND[γϕ]◦NL[γ].(72) When both channels are active, the amplitude of the total translation of a feature at radius ris, on average, ∆ξ(r) =r/radicalbigg γ+2 πγ2 ϕ.(73) Coming back to finite",
    "and dephasing channel commute [27] and, therefore, the general noise channel can be described as a composition of both: NLD[γ,γϕ] =NL[γ]◦ND[γϕ] =ND[γϕ]◦NL[γ].(72) When both channels are active, the amplitude of the total translation of a feature at radius ris, on average, ∆ξ(r) =r/radicalbigg γ+2 πγ2 ϕ.(73) Coming back to finite energy GKP codes, each feature of the Wigner function of a GKP state is a Gaussian (more details in Sect. 5.2). When both bosonic loss and dephasing are considered, each Gaussian that composes the full Wigner function will be translated on average by an amplitude of∆ξ(r)depending on its position at each application of the channel. The separate and combined effects of the two noise channels are shown in Fig. 2. When∆ξ(r)becomes of a length similar to the logical operators of the code, the logical error rate increases. It then becomes important to minimize the radial position of the full finite energy GKP state, which in turn suggests that the position of the envelopeµE should be minimized at every step of a computation. Accordingly, we compare different implementations with the metric d2 µ(µE) =µT EµE.(74) 13 <latexit sha1_base64=\"iP5e2g86QPJfSUrEzDPiZE0dxaU=\">AAACVnicbVBdSxtBFJ1dtaaxtlEf+7IYBPtg2BVRHwN96WME8wG7i8xO7iZDZmanM3eVsOzf6Gv7s+qfEScxoCYeGDiccy73zsm04BbD8NHzt7Z3Pu02Pjf3vux//dY6OBzYojQM+qwQhRll1ILgCvrIUcBIG6AyEzDMZj8X/vAejOWFusW5hlTSieI5ZxSdlJydJ/a3wSrRvL5rtcNOuESwSaIVaZMVencH3kUyLlgpQSET1No4CjWmFTXImYC6mZQWNGUzOoHYUUUl2LRaHl0HJ04ZB3lh3FMYLNW3ExWV1s5l5pKS4tSuewvxIy8uMb9OK650iaDYy6K8FAEWwaKBYMwNMBRzRygz3N0asCk1lKHr6d2WzNAZoPuHggdWSEnV2DWl6zhKq0RAjqdVO6oTwydT/LEWy7LXWPwaS+um6zlab3WTDM470WXn8uai3e2uGm+Q7+SYnJKIXJEu+UV6pE8Y0eQP+Uv+ef+9J3/H332J+t5q5oi8g996BjmhtcI=</latexit>\u00002p⇡<latexit sha1_base64=\"Yd2a8DT+0OP0MPhecz9UeA9YLGI=\">AAACVXicbVDLSsNAFJ3Ed33r0k2wCLopiRR1WXDjUsGqkASZTG/aofOIMzdKCfkMt/pZ4scITmtBrR4YOJxzLvfOyQrBLYbhu+fPzS8sLi2vNFbX1jc2t7Z3bqwuDYMu00Kbu4xaEFxBFzkKuCsMUJkJuM2G52P/9hGM5Vpd46iAVNK+4jlnFJ0UHyf2wWCVFLy+32qGrXCC4C+JpqRJpri83/baSU+zUoJCJqi1cRQWmFbUIGcC6kZSWigoG9I+xI4qKsGm1eTmOjhwSi/ItXFPYTBRf05UVFo7kplLSooDO+uNxf+8uMT8LK24KkoExb4W5aUIUAfjAoIeN8BQjByhzHB3a8AG1FCGrqZfWzJDh4DuHwqemJaSqp5rqqjjKK0SATkeVs2oTgzvD/BoJpZl37H4O5bWDddzNNvqX3Jz3IpOWidX7WanM218meyRfXJIInJKOuSCXJIuYUSTZ/JCXr0378Of9xe/or43ndklv+BvfgK8rbWL</latexit>2p⇡<latexit sha1_base64=\"iP5e2g86QPJfSUrEzDPiZE0dxaU=\">AAACVnicbVBdSxtBFJ1dtaaxtlEf+7IYBPtg2BVRHwN96WME8wG7i8xO7iZDZmanM3eVsOzf6Gv7s+qfEScxoCYeGDiccy73zsm04BbD8NHzt7Z3Pu02Pjf3vux//dY6OBzYojQM+qwQhRll1ILgCvrIUcBIG6AyEzDMZj8X/vAejOWFusW5hlTSieI5ZxSdlJydJ/a3wSrRvL5rtcNOuESwSaIVaZMVencH3kUyLlgpQSET1No4CjWmFTXImYC6mZQWNGUzOoHYUUUl2LRaHl0HJ04ZB3lh3FMYLNW3ExWV1s5l5pKS4tSuewvxIy8uMb9OK650iaDYy6K8FAEWwaKBYMwNMBRzRygz3N0asCk1lKHr6d2WzNAZoPuHggdWSEnV2DWl6zhKq0RAjqdVO6oTwydT/LEWy7LXWPwaS+um6zlab3WTDM470WXn8uai3e2uGm+Q7+SYnJKIXJEu+UV6pE8Y0eQP+Uv+ef+9J3/H332J+t5q5oi8g996BjmhtcI=</latexit>\u00002p⇡<latexit sha1_base64=\"Yd2a8DT+0OP0MPhecz9UeA9YLGI=\">AAACVXicbVDLSsNAFJ3Ed33r0k2wCLopiRR1WXDjUsGqkASZTG/aofOIMzdKCfkMt/pZ4scITmtBrR4YOJxzLvfOyQrBLYbhu+fPzS8sLi2vNFbX1jc2t7Z3bqwuDYMu00Kbu4xaEFxBFzkKuCsMUJkJuM2G52P/9hGM5Vpd46iAVNK+4jlnFJ0UHyf2wWCVFLy+32qGrXCC4C+JpqRJpri83/baSU+zUoJCJqi1cRQWmFbUIGcC6kZSWigoG9I+xI4qKsGm1eTmOjhwSi/ItXFPYTBRf05UVFo7kplLSooDO+uNxf+8uMT8LK24KkoExb4W5aUIUAfjAoIeN8BQjByhzHB3a8AG1FCGrqZfWzJDh4DuHwqemJaSqp5rqqjjKK0SATkeVs2oTgzvD/BoJpZl37H4O5bWDddzNNvqX3Jz3IpOWidX7WanM218meyRfXJIInJKOuSCXJIuYUSTZ/JCXr0378Of9xe/or43ndklv+BvfgK8rbWL</latexit>2p⇡ <latexit sha1_base64=\"NVqIR9w/USUgzf70Du/ed0eCbFs=\">AAACTXicbVBNS8NAEN3Ur1q/9eglWAS9lESKehEKXjxWtCokQTbbSbt0dxN3J0oJ+Qle9Wd59od4E3FbC2p1YODx3htm5sWZ4AY979WpzMzOzS9UF2tLyyura+sbm1cmzTWDDktFqm9iakBwBR3kKOAm00BlLOA6HpyO9Ot70Ian6hKHGUSS9hRPOKNoqYu7E+92ve41vHG5f4E/AXUyqfbthtMMuynLJShkghoT+F6GUUE1ciagrIW5gYyyAe1BYKGiEkxUjG8t3V3LdN0k1bYVumP250RBpTFDGVunpNg309qI/E8LckyOo4KrLEdQ7GtRkgsXU3f0uNvlGhiKoQWUaW5vdVmfasrQxvNrS6zpAND+oeCBpVJS1S3CLCsDPypCAQnuFXW/DDXv9XF/yhbH37bg2xaVNZuzP53qX3B10PAPG4fnzXqrNUm8SrbJDtkjPjkiLXJG2qRDGOmRR/JEnp0X5815dz6+rBVnMrNFflVl4RPOtbOS</latexit>q=0<latexit sha1_base64=\"p33nntgWnpq2IIVn+FwWdICACGk=\">AAACTXicbVBNS8NAEN3U7/qtRy/BIuilJCLqRSh48ahoVUiCbLaTdunuZtmdKCXkJ3jVn+XZH+JNxG0tqNWBgcd7b5iZl2rBLQbBq1ebmp6ZnZtfqC8uLa+srq1vXNu8MAzaLBe5uU2pBcEVtJGjgFttgMpUwE3aPx3qN/dgLM/VFQ40JJJ2Fc84o+ioS30S3K01gmYwKv8vCMegQcZ1frfuHcSdnBUSFDJBrY3CQGNSUoOcCajqcWFBU9anXYgcVFSCTcrRrZW/45iOn+XGtUJ/xP6cKKm0diBT55QUe3ZSG5L/aVGB2XFScqULBMW+FmWF8DH3h4/7HW6AoRg4QJnh7laf9aihDF08v7akhvYB3R8KHlguJVWdMta6isKkjAVkuFs2wio2vNvDvQlbmn7bom9bUtVdzuFkqn/B9X4zPGweXhw0Wq1x4vNki2yTXRKSI9IiZ+SctAkjXfJInsiz9+K9ee/ex5e15o1nNsmvqs19AszMs5E=</latexit>p=0 <latexit sha1_base64=\"iP5e2g86QPJfSUrEzDPiZE0dxaU=\">AAACVnicbVBdSxtBFJ1dtaaxtlEf+7IYBPtg2BVRHwN96WME8wG7i8xO7iZDZmanM3eVsOzf6Gv7s+qfEScxoCYeGDiccy73zsm04BbD8NHzt7Z3Pu02Pjf3vux//dY6OBzYojQM+qwQhRll1ILgCvrIUcBIG6AyEzDMZj8X/vAejOWFusW5hlTSieI5ZxSdlJydJ/a3wSrRvL5rtcNOuESwSaIVaZMVencH3kUyLlgpQSET1No4CjWmFTXImYC6mZQWNGUzOoHYUUUl2LRaHl0HJ04ZB3lh3FMYLNW3ExWV1s5l5pKS4tSuewvxIy8uMb9OK650iaDYy6K8FAEWwaKBYMwNMBRzRygz3N0asCk1lKHr6d2WzNAZoPuHggdWSEnV2DWl6zhKq0RAjqdVO6oTwydT/LEWy7LXWPwaS+um6zlab3WTDM470WXn8uai3e2uGm+Q7+SYnJKIXJEu+UV6pE8Y0eQP+Uv+ef+9J3/H332J+t5q5oi8g996BjmhtcI=</latexit>\u00002p⇡<latexit sha1_base64=\"Yd2a8DT+0OP0MPhecz9UeA9YLGI=\">AAACVXicbVDLSsNAFJ3Ed33r0k2wCLopiRR1WXDjUsGqkASZTG/aofOIMzdKCfkMt/pZ4scITmtBrR4YOJxzLvfOyQrBLYbhu+fPzS8sLi2vNFbX1jc2t7Z3bqwuDYMu00Kbu4xaEFxBFzkKuCsMUJkJuM2G52P/9hGM5Vpd46iAVNK+4jlnFJ0UHyf2wWCVFLy+32qGrXCC4C+JpqRJpri83/baSU+zUoJCJqi1cRQWmFbUIGcC6kZSWigoG9I+xI4qKsGm1eTmOjhwSi/ItXFPYTBRf05UVFo7kplLSooDO+uNxf+8uMT8LK24KkoExb4W5aUIUAfjAoIeN8BQjByhzHB3a8AG1FCGrqZfWzJDh4DuHwqemJaSqp5rqqjjKK0SATkeVs2oTgzvD/BoJpZl37H4O5bWDddzNNvqX3Jz3IpOWidX7WanM218meyRfXJIInJKOuSCXJIuYUSTZ/JCXr0378Of9xe/or43ndklv+BvfgK8rbWL</latexit>2p⇡<latexit sha1_base64=\"NVqIR9w/USUgzf70Du/ed0eCbFs=\">AAACTXicbVBNS8NAEN3Ur1q/9eglWAS9lESKehEKXjxWtCokQTbbSbt0dxN3J0oJ+Qle9Wd59od4E3FbC2p1YODx3htm5sWZ4AY979WpzMzOzS9UF2tLyyura+sbm1cmzTWDDktFqm9iakBwBR3kKOAm00BlLOA6HpyO9Ot70Ian6hKHGUSS9hRPOKNoqYu7E+92ve41vHG5f4E/AXUyqfbthtMMuynLJShkghoT+F6GUUE1ciagrIW5gYyyAe1BYKGiEkxUjG8t3V3LdN0k1bYVumP250RBpTFDGVunpNg309qI/E8LckyOo4KrLEdQ7GtRkgsXU3f0uNvlGhiKoQWUaW5vdVmfasrQxvNrS6zpAND+oeCBpVJS1S3CLCsDPypCAQnuFXW/DDXv9XF/yhbH37bg2xaVNZuzP53qX3B10PAPG4fnzXqrNUm8SrbJDtkjPjkiLXJG2qRDGOmRR/JEnp0X5815dz6+rBVnMrNFflVl4RPOtbOS</latexit>q=0 <latexit sha1_base64=\"iP5e2g86QPJfSUrEzDPiZE0dxaU=\">AAACVnicbVBdSxtBFJ1dtaaxtlEf+7IYBPtg2BVRHwN96WME8wG7i8xO7iZDZmanM3eVsOzf6Gv7s+qfEScxoCYeGDiccy73zsm04BbD8NHzt7Z3Pu02Pjf3vux//dY6OBzYojQM+qwQhRll1ILgCvrIUcBIG6AyEzDMZj8X/vAejOWFusW5hlTSieI5ZxSdlJydJ/a3wSrRvL5rtcNOuESwSaIVaZMVencH3kUyLlgpQSET1No4CjWmFTXImYC6mZQWNGUzOoHYUUUl2LRaHl0HJ04ZB3lh3FMYLNW3ExWV1s5l5pKS4tSuewvxIy8uMb9OK650iaDYy6K8FAEWwaKBYMwNMBRzRygz3N0asCk1lKHr6d2WzNAZoPuHggdWSEnV2DWl6zhKq0RAjqdVO6oTwydT/LEWy7LXWPwaS+um6zlab3WTDM470WXn8uai3e2uGm+Q7+SYnJKIXJEu+UV6pE8Y0eQP+Uv+ef+9J3/H332J+t5q5oi8g996BjmhtcI=</latexit>\u00002p⇡<latexit sha1_base64=\"Yd2a8DT+0OP0MPhecz9UeA9YLGI=\">AAACVXicbVDLSsNAFJ3Ed33r0k2wCLopiRR1WXDjUsGqkASZTG/aofOIMzdKCfkMt/pZ4scITmtBrR4YOJxzLvfOyQrBLYbhu+fPzS8sLi2vNFbX1jc2t7Z3bqwuDYMu00Kbu4xaEFxBFzkKuCsMUJkJuM2G52P/9hGM5Vpd46iAVNK+4jlnFJ0UHyf2wWCVFLy+32qGrXCC4C+JpqRJpri83/baSU+zUoJCJqi1cRQWmFbUIGcC6kZSWigoG9I+xI4qKsGm1eTmOjhwSi/ItXFPYTBRf05UVFo7kplLSooDO+uNxf+8uMT8LK24KkoExb4W5aUIUAfjAoIeN8BQjByhzHB3a8AG1FCGrqZfWzJDh4DuHwqemJaSqp5rqqjjKK0SATkeVs2oTgzvD/BoJpZl37H4O5bWDddzNNvqX3Jz3IpOWidX7WanM218meyRfXJIInJKOuSCXJIuYUSTZ/JCXr0378Of9xe/or43ndklv+BvfgK8rbWL</latexit>2p⇡<latexit sha1_base64=\"NVqIR9w/USUgzf70Du/ed0eCbFs=\">AAACTXicbVBNS8NAEN3Ur1q/9eglWAS9lESKehEKXjxWtCokQTbbSbt0dxN3J0oJ+Qle9Wd59od4E3FbC2p1YODx3htm5sWZ4AY979WpzMzOzS9UF2tLyyura+sbm1cmzTWDDktFqm9iakBwBR3kKOAm00BlLOA6HpyO9Ot70Ian6hKHGUSS9hRPOKNoqYu7E+92ve41vHG5f4E/AXUyqfbthtMMuynLJShkghoT+F6GUUE1ciagrIW5gYyyAe1BYKGiEkxUjG8t3V3LdN0k1bYVumP250RBpTFDGVunpNg309qI/E8LckyOo4KrLEdQ7GtRkgsXU3f0uNvlGhiKoQWUaW5vdVmfasrQxvNrS6zpAND+oeCBpVJS1S3CLCsDPypCAQnuFXW/DDXv9XF/yhbH37bg2xaVNZuzP53qX3B10PAPG4fnzXqrNUm8SrbJDtkjPjkiLXJG2qRDGOmRR/JEnp0X5815dz6+rBVnMrNFflVl4RPOtbOS</latexit>q=0 <latexit sha1_base64=\"iP5e2g86QPJfSUrEzDPiZE0dxaU=\">AAACVnicbVBdSxtBFJ1dtaaxtlEf+7IYBPtg2BVRHwN96WME8wG7i8xO7iZDZmanM3eVsOzf6Gv7s+qfEScxoCYeGDiccy73zsm04BbD8NHzt7Z3Pu02Pjf3vux//dY6OBzYojQM+qwQhRll1ILgCvrIUcBIG6AyEzDMZj8X/vAejOWFusW5hlTSieI5ZxSdlJydJ/a3wSrRvL5rtcNOuESwSaIVaZMVencH3kUyLlgpQSET1No4CjWmFTXImYC6mZQWNGUzOoHYUUUl2LRaHl0HJ04ZB3lh3FMYLNW3ExWV1s5l5pKS4tSuewvxIy8uMb9OK650iaDYy6K8FAEWwaKBYMwNMBRzRygz3N0asCk1lKHr6d2WzNAZoPuHggdWSEnV2DWl6zhKq0RAjqdVO6oTwydT/LEWy7LXWPwaS+um6zlab3WTDM470WXn8uai3e2uGm+Q7+SYnJKIXJEu+UV6pE8Y0eQP+Uv+ef+9J3/H332J+t5q5oi8g996BjmhtcI=</latexit>\u00002p⇡<latexit sha1_base64=\"Yd2a8DT+0OP0MPhecz9UeA9YLGI=\">AAACVXicbVDLSsNAFJ3Ed33r0k2wCLopiRR1WXDjUsGqkASZTG/aofOIMzdKCfkMt/pZ4scITmtBrR4YOJxzLvfOyQrBLYbhu+fPzS8sLi2vNFbX1jc2t7Z3bqwuDYMu00Kbu4xaEFxBFzkKuCsMUJkJuM2G52P/9hGM5Vpd46iAVNK+4jlnFJ0UHyf2wWCVFLy+32qGrXCC4C+JpqRJpri83/baSU+zUoJCJqi1cRQWmFbUIGcC6kZSWigoG9I+xI4qKsGm1eTmOjhwSi/ItXFPYTBRf05UVFo7kplLSooDO+uNxf+8uMT8LK24KkoExb4W5aUIUAfjAoIeN8BQjByhzHB3a8AG1FCGrqZfWzJDh4DuHwqemJaSqp5rqqjjKK0SATkeVs2oTgzvD/BoJpZl37H4O5bWDddzNNvqX3Jz3IpOWidX7WanM218meyRfXJIInJKOuSCXJIuYUSTZ/JCXr0378Of9xe/or43ndklv+BvfgK8rbWL</latexit>2p⇡<latexit sha1_base64=\"NVqIR9w/USUgzf70Du/ed0eCbFs=\">AAACTXicbVBNS8NAEN3Ur1q/9eglWAS9lESKehEKXjxWtCokQTbbSbt0dxN3J0oJ+Qle9Wd59od4E3FbC2p1YODx3htm5sWZ4AY979WpzMzOzS9UF2tLyyura+sbm1cmzTWDDktFqm9iakBwBR3kKOAm00BlLOA6HpyO9Ot70Ian6hKHGUSS9hRPOKNoqYu7E+92ve41vHG5f4E/AXUyqfbthtMMuynLJShkghoT+F6GUUE1ciagrIW5gYyyAe1BYKGiEkxUjG8t3V3LdN0k1bYVumP250RBpTFDGVunpNg309qI/E8LckyOo4KrLEdQ7GtRkgsXU3f0uNvlGhiKoQWUaW5vdVmfasrQxvNrS6zpAND+oeCBpVJS1S3CLCsDPypCAQnuFXW/DDXv9XF/yhbH37bg2xaVNZuzP53qX3B10PAPG4fnzXqrNUm8SrbJDtkjPjkiLXJG2qRDGOmRR/JEnp0X5815dz6+rBVnMrNFflVl4RPOtbOS</latexit>q=0 (a)(b)(c)(d)Figure 2:Noise application on GKP states.Effects of different error channels on the Wigner representation of the/vextendsingle/vextendsingle0/angbracketrightbig state of the square GKP code. (a) Unaffected state. (b) Amplitude damping with an average radial translation ofr√γ. (c) Dephasing with an average absolute angular translation of/radicalbig 2/πrγϕ. (d) Combined amplitude damping and dephasing. More generally, the argument toward reducing the number of excitations in the harmonic oscillator can be used more broadly for most error channels on harmonic oscillators (e.g. bosonic loss, dephasing, spurious Kerr non-linearity), as their effects increase with excita- tion number. We thus compute the average number of excitations in a GKP state described by generator matrixSand envelope(Σ E,µE) =/parenleftig MEΣ0MT E,µE/parenrightig , whereΣ 0contains the symplectic eigenvalues on the diagonal after a Williamson decomposition [28]. This result takes the form of a ponderated sum of the excitation contribution over all the Gaussian peaks in phase-space: /angbracketleftbigg ˆξTˆξ/angbracketrightbigg =/summationdisplay χE∈ΛEf(χE)/parenleftig χT EχE+Tr/bracketleftig MEtanh/parenleftig Σ−1 0/parenrightig MT E/bracketrightig/parenrightig ,(75) wheref(χE)is the ponderation coefficient (see Sect. E for the full derivation).Λ Eis the set of peak positions altered by the envelope. For eachλ∈Λ, we have an associated χE∈ΛEsuch that χE=MEsech/parenleftig Σ−1 0/parenrightig M−1 E[λ−µE] +µE.(76) The result of Eq. (75) reinforces the criterion of Eq. (74) because the envelope positionµE that minimizes the contribution /summationdisplay χEf(χE)χT EχE,(77) also minimizes d2 µ(µE). The second contribution to the excitation number is connected to the covariance matrix of the envelope /summationdisplay χEf(χE)Tr/bracketleftig MEtanh/parenleftig Σ−1 0/parenrightig MT E/bracketrightig .(78) The Williamson decomposition splits the covariance matrixΣ Einto the product of a sym- plectic matrixM Eand a positive definite diagonal matrixΣ 0. The trace contribution in Eq. (78) is invariant under orthogonal matrix congruence, leaving only the squeezing part ofMEcontributing non-trivially to/angbracketleftbigg ˆξTˆξ/angbracketrightbigg . The contribution increases with the amount of squeezing inM Eand is minimized whenM E∈O 2N(R)[29]. In order to compare the",
    "matrixM Eand a positive definite diagonal matrixΣ 0. The trace contribution in Eq. (78) is invariant under orthogonal matrix congruence, leaving only the squeezing part ofMEcontributing non-trivially to/angbracketleftbigg ˆξTˆξ/angbracketrightbigg . The contribution increases with the amount of squeezing inM Eand is minimized whenM E∈O 2N(R)[29]. In order to compare the susceptibility of different physical GKP states, we introduce an equivalent metric on covariance matrices d2 Σ(ΣE,Σ0) =Tr/bracketleftbigg ln2/parenleftbigg/radicalig Σ−1 0ΣE/radicalig Σ−1 0/parenrightbigg/bracketrightbigg ,(79) 14 withΣEthe covariance matrix of the envelope andΣ 0the optimal covariance matrix from the Williamson decomposition [30]. If we consider that all modes are similar, the initial parameters of the envelope are the ones of Eq. (63), which reduce the last metric to d2 Σ(ΣE,Σ0) =Tr/bracketleftig ln2(εΣE)/bracketrightig .(80) The metric in Eq. (79) is such that if a state minimizes it, then the contribution in Eq. (78) is also minimized. Therefore, to reduce the impact of noise channels on GKP states, we aim to reduce the amount of displacement and squeezing that are created by the chosen physical implementation. More general schemes could be designed for multimode GKP by playing with the trade-off of sending errors to one mode to gain fidelity in another. Using such a sacrificial mode could be an interesting optimization technique, but it is outside of the scope of this work. Combining both criteria of Eqs. (74) and (79), we can now compare different physical implementations of a logical Clifford gate, and we are ready to give an explicit description of our compiler algorithm. 5 Gaussian stabilizer compiler 5.1 Gaussian stabilizer compiler As described in the last section, a compiler algorithm selects an implementation given a logical circuit. When considering a physical representativeU 0for a logical operation on a code (we choose it closest to the identity for simplicity),U 0Sis the group of all implementations of the same logical operation:U 0S/vextendsingle/vextendsingle/vextendsingleΨ/angbracketrightig =U 0/vextendsingle/vextendsingle/vextendsingleΨ/angbracketrightig ∀S∈S, whereSis the stabilizer group that can be implemented. Here, we chooseSto be the gaussian stabilizer group. Any operation logically equivalent toU 0can be written as Imp/parenleftig U/parenrightig =U 0gn,(81) wheregncorrespond to the application of a sequence of at mostngenerators ofS(or their inverse). We can look atg nin Eq. (81) as a walk of length at mostnon the Cayley graph of the Gaussian stabilizer groupΓ (S G), with generating set as in Eq. (50). A compilation strategy is then translated to a choice of walk onΓ (S G). A simple compiling strategy is to choose a fixed implementation for a given operation, which we call below the constant compiler. Another compiling strategy, which we refer to as the random walk compiler, is to choose an implementation at random among the closest ones to the identity, by which we mean an implementation of the form of Eq. (81) withn= 1. This last strategy induces a random walk on the Cayley graphΓ (S G)interleaved with the basic physical representatives{U 0}. Both the constant and random walk compilers are suboptimal as the amount of squeezing and total displacement increases with the number of operations, as seen in Fig. 3. This remains true if we modify",
    "induces a random walk on the Cayley graphΓ (S G)interleaved with the basic physical representatives{U 0}. Both the constant and random walk compilers are suboptimal as the amount of squeezing and total displacement increases with the number of operations, as seen in Fig. 3. This remains true if we modify the random walk compiler to only sample from a smaller set of generators. To achieve an optimized circuit implementation, the metrics in Eqs. (74) and (79) should be minimized, among all possible walks onΓ (S G). However, because the Gaussian sta- bilizer is an infinite group, the metrics cannot be computed for all equivalent operations, and a cutoff needs to be defined. Because operations inS Gthat are far from the identity generate more squeezing and displacement, they are less likely to be useful in the optimiza- tion. Therefore, we only consider operations made of short sequences of generators of the stabilizer group. WithS Gfinitely generated, we can compute both metrics in Eqs. (74) 15 and (79) of all different walks onΓup to a finite lengthnand define the optimal encoded Clifford implementation as the path that minimizes the metrics at each step. This process is described in algorithm 1. The algorithm takes as input the target operationU 0and the parameters of the initial envelope (Σ iandµi). After comparing the different pathsg nonΓ of lengthn, it returns the optimal operationU optand the final parameters of the envelope (Σf,optandµf,opt). Below, we set the maximum lengthnto2. In general, pass a certain threshold, increasing the walk lengthnwill not necessarily increase the performance of the compiler. A lot of the times, only short walks onΓare used and increasingnwill not give better implementations of a gate. In algorithm 1, we choose to optimize the squeezing Algorithm 1Gaussian stabilizer compiler Input:U 0,Σi,µi Σf,opt←Σi µf,opt←µi gopt←I for allg n∈{gn}do Compute its symplectic representationU 0gn=ˆT(λ)UM ifd2 Σ/parenleftig MΣiMT,Σ0/parenrightig <d2 Σ(Σf,opt,Σ0)then Σf,opt←MΣiMT µf,opt←Mµi+λ gopt←gn else ifd2 Σ/parenleftig MΣiMT,Σ0/parenrightig =d2 Σ(Σf,opt,Σ0)andd2 µ(Mµi+λ)<d2 µ/parenleftig µf,opt/parenrightig then Σf,opt←MΣiMT µf,opt←Mµi+λ gopt←gn end if end for returnU 0gopt,Σf,opt,µf,opt parameter first and then the displacement since squeezing is typically a larger limiter of the performance of error correction protocols. Below, we compare the performance of the Gaussian stabilizer compiler with the constant and random walk compilers and show that it outperforms both of them. 5.2 Performance of the GS compiler A method to compare different implementations of gates at the encoded level is logical randomized benchmarking (LRB) [31]. Randomized benchmarking (RB) methods are effi- cient ways to characterize and compare gate set implementations, in a way that the effects of state preparation and measurement errors can be factored out [32, 33]. When applying sequences of gates from a groupGto a system, the final state is affected compoundly by the decoherence that happens during each gate. The result of the following measurement is then a function of the error channel and the length of the sequence. When the gate imple- mentations are multiplicity-free representations of the target groupGand the error model is Markovian and time-independent, the survival probability is well described by a sum of decaying exponentials in the number",
    "following measurement is then a function of the error channel and the length of the sequence. When the gate imple- mentations are multiplicity-free representations of the target groupGand the error model is Markovian and time-independent, the survival probability is well described by a sum of decaying exponentials in the number of operations [34]. However, in the setup of LRB, the condition of multiplicity-free representations is often unfulfilled and non-exponential behaviour can appear [35]. In some cases, the survival probability remains a monotonically non-increasing function of the sequence length and can still be used as a measure of perfor- 16 160320Average number of Physical gate 0408012341Survival probability270540Average number of Physical gate 01020Number of logical CliÆord0123121Survival probability 05101520Number of logical CliÆord010002000d2µTrivial compilerGS compiler05101520Number of logical CliÆord10110111021d2ßRW compilerConstant compiler(a)(b) (c)(d)Figure 3:Logical randomized benchmarking results.Survival probability for the constant compiler (red), random walk (purple) and Gaussian stabilizer compiler (green) on square GKP codes with varying sequence length. We have also included the average survival probability curve when no logical operation is applied (blue) as an indicator. The average survival probability curves are shown for (a) 1 and (b) 3 logical qubits with loss strengthγ= 0.999andγ= 0.9999, respectively. The dashed line indicates the survival probability for a fully mixed logical state. For the simulations included in the decay curve (b), we compute (c) the maximum position metric of Eq. (74) and (d) the maximum squeezing metric of Eq. (79) reached as a function of logical circuit length. mance, but without links to the average gate fidelity. To obtain a measure of performance of the GKP Gaussian compiler, we perform logical randomized benchmarking by sampling uniformly the encoded Clifford group. As encoded Clifford operations are represented by Gaussian operations that are not multiplicity-free, we do not expect to obtain pure ex- ponential decay (at least not for small sequence length [34]). Furthermore, the Gaussian stabilizer compiler presented in algorithm 1 does not respect the Markovian condition as it selects gate implementations based on the previous ones in the circuit. Although Marko- vian noise is a necessary condition for classic RB methods, correlations between the gates, and so between noise applications, are exactly how we gain in performance against deco- herence. By using LRB, we do not aim specifically to obtain an error rate for our gate set, but instead aim to compare different compilation strategies for the encoded circuit. An implementation strategy is better than another if, for all circuit lengths, the probability of getting the correct result is greater. Alternatively, it means that longer circuits can be implemented with the same success probability. With the goal of doing an LRB analysis, we simulate GKP states by following the evolution of their Wigner function in phase-space with the tools developed in Ref. [36]. In this setup, the Wigner function of a finite energy GKP grid state is described as a sum of Gaussian functions in phase space: WGKP(ξ) =/summationdisplay m∈McmGΣm,µm(ξ),(82) withG Σm,µm(ξ)defined in Eq. (21) and the setMindexing the Gaussian functions. 17 The normalization condition reads/summationtext m∈Mcm= 1for this representation. We have also generalized the results of [36]",
    "function of a finite energy GKP grid state is described as a sum of Gaussian functions in phase space: WGKP(ξ) =/summationdisplay m∈McmGΣm,µm(ξ),(82) withG Σm,µm(ξ)defined in Eq. (21) and the setMindexing the Gaussian functions. 17 The normalization condition reads/summationtext m∈Mcm= 1for this representation. We have also generalized the results of [36] to obtain a representation of the form of Eq. (82) for any multimode GKP grid state with potentially squeezed and displaced envelope in Sects. C and D. For simplicity, we consider that the system is initialized in a way that all modes are decoupledfromeachotherΣ E=ε−1⊕ε−1andµE=0asinEq.(64). Thoseconsiderations lead to an initial state with with parameters Σm=1 4πcoth/parenleftig Σ−1 E/parenrightig ,µm=sech/parenleftig Σ−1 E/parenrightig µS,m,(83) whereµS,mis the position of each Dirac delta function in the infinite energy description of the state with stabilizer generator matrixSderived in Sect. C. This description of the state as a sum of Gaussian functions in phase space has many advantages. The most useful being that we can follow its evolution under all Gaussian operations and Gaussian noise channels by updating the parameters in Eq. (83). Under any Gaussian operation, the parameters of the envelope are updated like in Eq. (66). This rule can also be used for the dephasing channel of Eq. (71) if we use a Monte Carlo method to model this channel as a random rotation of each mode. For bosonic loss, the parameters are updated with Σm→γΣm+1−γ 4πI,µm→√γµm,(84) when the loss parameter isγ. Furthermore, we can compute the characteristic function for Wigner functions of the form of Eq. (82) analytically. This enables us to efficiently compute averages of displacement operators, including logical operators of GKP codes. Hence, we can perform GKP state preparation, state evolution under logical Clifford cir- cuits and survival probability measurements efficiently. Using this simulation technique, we performed LRB simulations for 1,2 and 3 logical qubits encoded in a square GKP code. The results for 1 and 3 qubits are showcased in Fig. 3 in panels a and b, respectively. As expected, the decay curves do not exhibit the regular exponential behaviour for short sequences, but rather a Gaussian behaviour. This can be explained by the shape of the characteristic function of the finite-energy GKP states. This function, like its Wigner func- tion, is composed of a sum of many Gaussian features. The effect of the noise channel is to shift the peaks of the Gaussian away from the measured points, leading to a reduction in the survival probability. For short sequences of gates, the resulting shape of the decay then corresponds to the shape of the characteristic function near the measured point. For longer logical circuits, logical Pauli errors become more important, and we recover the exponential decay behaviour. As discussed at the beginning of the section, even if the decay does not follow an exponential behaviour, we still obtain a lifetime ordering of the different compilation strategies. Figure 3 demonstrates that the constant and random walk compilers have similar perfor- mance, while the Gaussian stabilizer compiler performs better. In this situation, we ex- pected the constant and random compiler to perform similarly.",
    "follow an exponential behaviour, we still obtain a lifetime ordering of the different compilation strategies. Figure 3 demonstrates that the constant and random walk compilers have similar perfor- mance, while the Gaussian stabilizer compiler performs better. In this situation, we ex- pected the constant and random compiler to perform similarly. Since the logical Hadamard gate is implemented via aπ/2phase-space rotation, it leads to an inversion of coordinates in phase-space, which means that the randomness from the circuit sampling step can also be understood as a random walk, leading to similar performance as the random walk com- piler. We observe that in all cases, the Gaussian stabilizer compiler performs better than the other two compilers. We also observe that, as expected, both the displacement and squeezing metrics remain low during computations with the GS compiler. To extract a computation lifetime, we fit a Gaussian function on the survival probabilityP(x) P(x) =Ae−(ax2+bx)+B,(85) 18 10°510°410°310°210°1∑t100101102tGSC/tRWC1 mode2 modes3 modes0100200300400500Number of two qubit gates122123221Survival probability(a)(b)Figure 4:Performance of the GS compiler with varying randomized benchmarking conditions. (a) Lifetime amelioration factor between the Gaussian stabilizer compiler and random walk compiler as a function of loss rate (κt). (b) Results of two-qubit gates randomized benchmarking with the group/angbracketleftbig CX,CZ/angbracketrightbig and loss parameterγ= 0.999. The figure shows the survival probability for the constant compiler (red), random walk (purple) and Gaussian stabilizer compiler (green) on two logical square GKP codes with varying sequence length. wherexis the number of logical gates applied. For all decay curves, we define the compu- tation lifetimetas the number of logical operations that we need to apply to reduce the survival probability by a factor of1/e: P(t) =Ae−1+B.(86) This definition of the lifetime allows us to compare both Gaussian and exponential fits on an equal footing. The amelioration factor, defined as the ratio of the GS compiler lifetime over the random walk compiler lifetime, is dependent on bosonic loss strength. As shown in Fig. 4 (a), we obtain that, at low loss rate, the GS compiler performs even better. When the loss rate is high, no compiler can help preserve the logical information and the computation fails with high probability in all cases. Finally, we performed similar LRB simulations, but now replacing the full Clifford group with two-qubit gates only. This scenario is relevant in a situation where a quantum com- pution is performed with magic state injection and Clifford gates. In this case, all single- qubit Clifford gates can be performed in a Pauli and Clifford frame, leaving only two-qubit gates to be implemented physically. As a result, only squeezing would play a role here, since all displacement operations would be removed. The result of a logical randomized benchmarking simulation with only two-qubit gates on two logical qubits is included in Fig. 4 (b). We find that the Gaussian stabilizer compiler still performs well in this setup compared to other compiling strategies. As a final note, we remark that interleaving quantum error correction gadgets in GKP logical circuits will have an effect on the envelope and might affect the results presented here. For example, error correction via",
    "the Gaussian stabilizer compiler still performs well in this setup compared to other compiling strategies. As a final note, we remark that interleaving quantum error correction gadgets in GKP logical circuits will have an effect on the envelope and might affect the results presented here. For example, error correction via state teleportation resets the envelope of the state, and the sBs protocol stabilizes a centered envelope. However, we believe that our Gaussian stabilizer compiler will remain useful with hybrid approaches depending on the actual implementation of error correction. We leave the analysis of combining quantum error correction schemes with the GS compiler to future work. 6 Conclusion In this work, we have investigated how to leverage more symmetries of GKP codes to reduce the impact of noise at the logical level. We first presented how we can obtain more 19 symmetries of a code by relaxing the restriction to abelian stabilizer groups. This new perspective enables us to find all symmetry operations related to an implementation of a logicaloperator. RestrictingthissettoGaussianoperations,weshowedthatitispossibleto describe the Gaussian symmetry group with only a few generators for any lattice describing a GKP code. This new set of non-commuting stabilizers can be used similarly to the commuting ones, such as for state stabilization, quantum error correction and decoding. In future work, we aim to characterize more thoroughly this connection between non-abelian stabilizer groups and potential applications in quantum error correction. ExploringthepassagefrominfinitetofiniteenergyGKPstate,wefoundthatinfiniteenergy stabilizers become logical stabilizers, but not physical stabilizers. As a first application of GKP non-abelian stabilizer groups, we presented a compiler algorithm that uses those logical symmetries on the finite-energy version of GKP codes to reduce the impact of loss and dephasing. This compiler works by selecting an implementation of a logical operation that reduces as much as possible the amount of total displacement and squeezing. Doing so reduces the mean excitation number in the oscillator and, by consequence, reduces the impact of loss and dephasing. We conjecture that it should also increase the protection against other noise channels, such as Kerr non-linearity. We leave that analysis for future work. It would also be interesting to explore how non-Gaussian stabilizer operations can fit within this formalism and increase their fidelity. WeshowedthatweobtainanameliorationincomputationlifetimewhileusingtheGaussian stabilizer compiler, and that this amelioration increases with the reduction of loss strength. WhiletheGScompileronlyusestheGKPsymmetriestorecenterandunsqueezedtheinter- mediate states of a computation, it seems probable that dynamical decoupling techniques at the compilation level could help symmetrize the effects of noise and further reduce its impact. It is conceivable that GKP codes will be used as a base layer for a fault-tolerant quantum computer, with a top-layer qubit code [37]. To reach this goal, it is primordial to have good native operations on the base layer combined with a performant compilation strategy. In this paper, we have introduced one such strategy. Acknowledgments This research was undertaken thanks in part to funding from the Canada First Research Excellence Fund. This research was also funded by the National Science and Engineering Council with a Canada Graduate Research Scholarship – Doctoral, by the Army Research Office under grant #W911NF2310045 and by a Université de",
    "Acknowledgments This research was undertaken thanks in part to funding from the Canada First Research Excellence Fund. This research was also funded by the National Science and Engineering Council with a Canada Graduate Research Scholarship – Doctoral, by the Army Research Office under grant #W911NF2310045 and by a Université de Sherbrooke Research Excel- lence Scholarships. References [1] V. V. Sivak, A. Eickbusch, B. Royer, S. Singh, I. Tsioutsios, S. Ganjam, A. Miano, B.L.Brock, A.Z.Ding, L.Frunzio, S.M.Girvin, R.J.Schoelkopf, andM.H.Devoret. “Real-time quantum error correction beyond break-even”. Nature616, 50–55 (2023). arXiv:2211.09116. [2] Dany Lachance-Quirion, Marc-Antoine Lemonde, Jean Olivier Simoneau, Lucas St- Jean, Pascal Lemieux, Sara Turcotte, Wyatt Wright, Amélie Lacroix, Joëlle Fréchette- Viens, Ross Shillito, Florian Hopfmueller, Maxime Tremblay, Nicholas E. Frat- 20 tini, Julien Camirand Lemyre, and Philippe St-Jean. “Autonomous Quantum Er- ror Correction of Gottesman-Kitaev-Preskill States”. Physical Review Letters132, 150607 (2024). [3] Benjamin L. Brock, Shraddha Singh, Alec Eickbusch, Volodymyr V. Sivak, Andy Z. Ding, Luigi Frunzio, Steven M. Girvin, and Michel H. Devoret. “Quantum error correction of qudits beyond break-even”. Nature641, 612–618 (2025). [4] Nissim Ofek, Andrei Petrenko, Reinier Heeres, Philip Reinhold, Zaki Leghtas, Brian Vlastakis, Yehan Liu, Luigi Frunzio, S. M. Girvin, L. Jiang, Mazyar Mirrahimi, M. H. Devoret, and R. J. Schoelkopf. “Extending the lifetime of a quantum bit with error correction in superconducting circuits”. Nature536, 441–445 (2016). [5] Shunya Konno, Warit Asavanant, Fumiya Hanamura, Hironari Nagayoshi, Kosuke Fukui, Atsushi Sakaguchi, Ryuhoh Ide, Fumihiro China, Masahiro Yabuno, Shigehito Miki, Hirotaka Terai, Kan Takase, Mamoru Endo, Petr Marek, Radim Filip, Peter van Loock, and Akira Furusawa. “Logical states for fault-tolerant quantum computation with propagating light”. Science383, 289–293 (2024). [6] M. V. Larsen, J. E. Bourassa, S. Kocsis, J. F. Tasker, R. S. Chadwick, C. González- Arciniegas, J. Hastrup, C. E. Lopetegui-González, F. M. Miatto, A. Motamedi, R.Noro,G.Roeland,R.Baby,H.Chen,P.Contu,I.DiLuch,C.Drago,M.Giesbrecht, T. Grainge, I. Krasnokutska, M. Menotti, B. Morrison, C. Puviraj, K. Rezaei Shad, B. Hussain, J. McMahon, J. E. Ortmann, M. J. Collins, C. Ma, D. S. Phillips, M. Sey- mour, Q.Y.Tang, B.Yang, Z.Vernon, R.N.Alexander, andD.H.Mahler. “Integrated photonic source of Gottesman–Kitaev–Preskill qubits”. Nature642, 587–591 (2025). [7] Brennan de Neeve, Thanh-Long Nguyen, Tanja Behrle, and Jonathan P. Home. “Error correction of a logical grid state qubit by dissipative pumping”. Nature Physics18, 296–300 (2022). [8] V. G. Matsos, C. H. Valahu, T. Navickas, A. D. Rao, M. J. Millican, X. C. Kolesnikow, M. J. Biercuk, and T. R. Tan. “Robust and Deterministic Preparation of Bosonic Logical States in a Trapped Ion”. Physical Review Letters133, 050602 (2024). [9] V. G. Matsos, C. H. Valahu, M. J. Millican, T. Navickas, X. C. Kolesnikow, M. J. Biercuk, and T. R. Tan. “Universal quantum gate set for Gottesman–Kitaev–Preskill logical qubits”. Nature PhysicsPages 1–6 (2025). [10] Daniel Gottesman, Alexei Kitaev, and John Preskill. “Encoding a qubit in an oscilla- tor”. Physical Review A64, 012310 (2001). arXiv:quant-ph/0008040. [11] Kyungjoo Noh, Victor V. Albert, and Liang Jiang. “Quantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev- Preskill Codes”. IEEE Transactions on Information Theory65, 2563–2582 (2019). [12] Peter Leviant, Qian Xu, Liang Jiang, and Serge Rosenblum. “Quantum capac- ity and",
    "Review A64, 012310 (2001). arXiv:quant-ph/0008040. [11] Kyungjoo Noh, Victor V. Albert, and Liang Jiang. “Quantum Capacity Bounds of Gaussian Thermal Loss Channels and Achievable Rates With Gottesman-Kitaev- Preskill Codes”. IEEE Transactions on Information Theory65, 2563–2582 (2019). [12] Peter Leviant, Qian Xu, Liang Jiang, and Serge Rosenblum. “Quantum capac- ity and codes for the bosonic loss-dephasing channel”. Quantum6, 821 (2022). arXiv:2205.00341. [13] Sergey Bravyi and Alexei Kitaev. “Universal quantum computation with ideal Clifford gates and noisy ancillas”. Physical Review A71, 022316 (2005). 21 [14] Baptiste Royer, Shraddha Singh, and S. M. Girvin. “Stabilization of Finite-Energy Gottesman-Kitaev-Preskill States”. Physical Review Letters125, 260509 (2020). arXiv:2009.07941. [15] Ilan Tzitrin, J. Eli Bourassa, Nicolas C. Menicucci, and Krishna Kumar Sabapathy. “Progress towards practical qubit computation using approximate Gottesman-Kitaev- Preskill codes”. Physical Review A101, 032315 (2020). [16] Jim Harrington and John Preskill. “Achievable rates for the Gaussian quantum chan- nel”. Physical Review A64, 062301 (2001). [17] Jonathan Conrad, Jens Eisert, and Francesco Arzani. “Gottesman-Kitaev-Preskill codes: A lattice perspective”. Quantum6, 648 (2022). arXiv:2109.14645. [18] Baptiste Royer, Shraddha Singh, and Steven M. Girvin. “Encoding qubits in multi- mode grid states”. PRX Quantum3, 010335 (2022). arXiv:2201.12337. [19] Daniel Gottesman. “Stabilizer Codes and Quantum Error Correction, Caltech Ph.D. thesis” (1997). arXiv:quant-ph/9705052. [20] Xiaotong Ni, Oliver Buerschaper, and Maarten Van den Nest. “A non-commuting stabilizer formalism”. Journal of Mathematical Physics56, 052201 (2015). [21] Mark A. Webster, Benjamin J. Brown, and Stephen D. Bartlett. “The XP Stabiliser Formalism: AGeneralisationofthePauliStabiliserFormalismwithArbitraryPhases”. Quantum6, 815 (2022). [22] JérémieBoudreault,RossShillito,Jean-BaptisteBertrand,andBaptisteRoyer. “Using a Kerr interaction for GKP magic state preparation” (2025). arXiv:2507.09684. [23] Narayanan Rengaswamy, Robert Calderbank, Swanand Kadhe, and Henry D. Pfister. “Logical Clifford Synthesis for Stabilizer Codes”. IEEE Transactions on Quantum Engineering1, 1–17 (2020). [24] Eric J. Kuehnke, Kyano Levi, Joschka Roffe, Jens Eisert, and Daniel Miller. “Hardware-tailored logical Clifford circuits for stabilizer codes” (2025). arXiv:2505.20261. [25] Jonathan Conrad, Ansgar G. Burchards, and Steven T. Flammia. “Lattices, Gates, and Curves: GKP codes as a Rosetta stone” (2024). arXiv:2407.03270. [26] Mao Lin, Christopher Chamberland, and Kyungjoo Noh. “Closest Lattice Point Decoding for Multimode Gottesman-Kitaev-Preskill Codes”. PRX Quantum4, 040334 (2023). [27] Christian Weedbrook, Stefano Pirandola, Raúl García-Patrón, Nicolas J. Cerf, Timo- thy C. Ralph, Jeffrey H. Shapiro, and Seth Lloyd. “Gaussian quantum information”. Reviews of Modern Physics84, 621–669 (2012). [28] Martin Houde, Will McCutcheon, and Nicolás Quesada. “Matrix decompositions in quantum optics: Takagi/Autonne, Bloch–Messiah/Euler, Iwasawa, and Williamson”. Canadian Journal of Physics102, 497–507 (2024). [29] Rajendra Bhatia and Tanvi Jain. “On symplectic eigenvalues of positive definite ma- trices”. Journal of Mathematical Physics56, 112201 (2015). arXiv:1803.04647. 22 [30] Wolfgang Förstner and Boudewijn Moonen. “A Metric for Covariance Matrices”. In Erik W. Grafarend, Friedrich W. Krumm, and Volker S. Schwarze, editors, Geodesy- The Challenge of the 3rd Millennium. Pages 299–309. Springer Berlin Heidelberg, Berlin, Heidelberg (2003). [31] Joshua Combes, Christopher Granade, Christopher Ferrie, and Steven T. Flammia. “Logical Randomized Benchmarking” (2017). arXiv:1702.03688. [32] Joseph Emerson, Robert Alicki, and Karol Życzkowski. “Scalable noise estimation with random unitary operators”. Journal of Optics B: Quantum and Semiclassical Optics7, S347 (2005). [33] E. Knill, D. Leibfried, R. Reichle, J. Britton, R. B. Blakestad, J. D. Jost, C. Langer,",
    "Steven T. Flammia. “Logical Randomized Benchmarking” (2017). arXiv:1702.03688. [32] Joseph Emerson, Robert Alicki, and Karol Życzkowski. “Scalable noise estimation with random unitary operators”. Journal of Optics B: Quantum and Semiclassical Optics7, S347 (2005). [33] E. Knill, D. Leibfried, R. Reichle, J. Britton, R. B. Blakestad, J. D. Jost, C. Langer, R. Ozeri, S. Seidelin, and D. J. Wineland. “Randomized benchmarking of quantum gates”. Physical Review A77, 012307 (2008). [34] J. Helsen, I. Roth, E. Onorati, A.H. Werner, and J. Eisert. “General Framework for Randomized Benchmarking”. PRX Quantum3, 020357 (2022). [35] Athena Ceasura, Pavithran Iyer, Joel J. Wallman, and Hakop Pashayan. “Non-Exponential Behaviour in Logical Randomized Benchmarking” (2022). arXiv:2212.05488. [36] J. Eli Bourassa, Nicolás Quesada, Ilan Tzitrin, Antal Száva, Theodor Isacsson, Josh Izaac, Krishna Kumar Sabapathy, Guillaume Dauphinais, and Ish Dhand. “Fast sim- ulation of bosonic qubits via Gaussian functions in phase space”. PRX Quantum2, 040315 (2021). arXiv:2103.05530. [37] Kyungjoo Noh, Christopher Chamberland, and Fernando G.S.L. Brandão. “Low- Overhead Fault-Tolerant Quantum Error Correction with the Surface-GKP Code”. PRX Quantum3, 010315 (2022). [38] David Mumford. “Tata Lectures on Theta I”. Modern Birkhauser Classics. Birkhauser Boston. Boston, MA (2007). [39] GeorgeA.Baker. “FormulationofQuantumMechanicsBasedontheQuasi-Probability Distribution Induced on Phase Space”. Physical Review109, 2198–2206 (1958). [40] Howard J. Carmichael. “Statistical Methods in Quantum Optics 1”. Springer Berlin Heidelberg. Berlin, Heidelberg (1999). A Derivation of gaussian stabilizer Starting from Eq. (36), we derive in this section the condition onMsuch that it defines a symplectic automorphism of the grid. In Sect. 3.2, we derived that the vector(M−I)pj must be part of the gridΛ. A general elementp0ofΛcan always be written asp0= STafora∈Z2N. At the same time, a vectorpjof the dual grid can always be written as pj= ΩS−1bforb∈Z2N. Equation (36) is modified to (M−I) ΩS−1b=STa.(87) There always exist a matrixX∈Mat 2N(Z), potentially singular, such thata=−Xb. Equation (87) then becomes (M−I) ΩS−1b=−STXb=⇒M=STXSΩ +I.(88) 23 But we know thatA=SΩST, from which we have the form of Eq. (37) M=ST(XA+I)S−T.(89) To force this matrix to be symplectic, we need thatMΩMT= Ω. This condition becomes ST(XA+I)S−TΩS−1/parenleftig ATXT+I/parenrightig S= Ω.(90) Using the relationA=SΩSTand the skew-symmetry ofA, we arrive at the conclusion of Eq. (38): XAXT−X+XT= 0.(91) B Generalized multimode sBs protocol In this section, we derive a generalized sBs protocol to stabilize finite-energy GKP code- words with a general Fock-type envelope. We start by computing the normalized stabilizers of Eq. (62). To compute the effect of the normalization on the stabilizers, we only need to understand how it acts on the quadrature operators since E(ΣE,µE)ˆT(v)E(Σ E,µE)−1= e−ilvTΩE(ΣE,µE)ˆξE(ΣE,µE)−1(92) A general Gaussian envelope is described by a real symmetric matrix of covarianceΣ E and a vector of meansµE. Any real symmetric matrix has a symplectic decomposition ΣE=MΣ 0MT, whereΣ 0=ε−1⊕ε−1is diagonal and positive definite andMis a symplectic matrix. Using this decomposition, the envelope operator can be rewritten as E(ΣE,µE) =ˆT(µE)UME(Σ 0,0)U† MˆT(µE)†,(93) which means that the action of the envelope on the quadrature operators can be written as E(ΣE,µE)ˆξE(ΣE,µE)−1=ˆT(µE)UME(Σ 0,0)/bracketleftig Mˆξ+µE/bracketrightig E(Σ 0,0)−1U† MˆT(µE)†. (94) The envelope operatorE(Σ 0,0)acts element-wise on each quadrature, leading to the simplification E(ΣE,µE)ˆξE(ΣE,µE)−1=ˆT(µE)UM/bracketleftig ME(Σ 0,0)ˆξE(Σ 0,0)−1+µE/bracketrightig U† MˆT(µE)†. (95) For a diagonal covariance matrixΣ",
    "=ˆT(µE)UME(Σ 0,0)U† MˆT(µE)†,(93) which means that the action of the envelope on the quadrature operators can be written as E(ΣE,µE)ˆξE(ΣE,µE)−1=ˆT(µE)UME(Σ 0,0)/bracketleftig Mˆξ+µE/bracketrightig E(Σ 0,0)−1U† MˆT(µE)†. (94) The envelope operatorE(Σ 0,0)acts element-wise on each quadrature, leading to the simplification E(ΣE,µE)ˆξE(ΣE,µE)−1=ˆT(µE)UM/bracketleftig ME(Σ 0,0)ˆξE(Σ 0,0)−1+µE/bracketrightig U† MˆT(µE)†. (95) For a diagonal covariance matrixΣ 0, we get E(Σ 0,0)ˆξE(Σ 0,0)−1=/bracketleftig cosh/parenleftig Σ−1 0/parenrightig +isinh/parenleftig Σ−1 0/parenrightig Ω/bracketrightigˆξ, ≡h(Σ 0)ˆξ,(96) resulting in the full expression E(ΣE,µE)ˆξE(ΣE,µE)−1=Mh(Σ 0)M−1/bracketleftigˆξ−µE/bracketrightig +µE.(97) Inserting this last equation into Eq. (92), we arrive at the expression of the finite-energy code stabilizers ˆTΣE,µE(sj) = exp/parenleftig −ilsT jΩµE/parenrightig exp/parenleftig −ilsT jΩMh(Σ 0)M−1/bracketleftigˆξ−µE/bracketrightig/parenrightig .(98) 24 A state described by a translated envelope is stabilized by the same protocol as a centered one, but with a different gauge. Moving forward, we will omit this phase for simplicity and focus solely on finding an implementation for the second term. Following the derivation of Ref. [14], we compute the set of nullifiers ˆdj=i√ 2lnˆTΣE,µE(sj)(99) =l√ 2sT jΩMcosh/parenleftig Σ−1 0/parenrightig M−1/bracketleftigˆξmod−µE/bracketrightig +il√ 2sT jΩMsinh/parenleftig Σ−1 0/parenrightig ΩM−1/bracketleftigˆξ−µE/bracketrightig thatenablethestabilizationofthedesiredmanifoldgiventheimplementationoftheunitary ˆUj= e−iΓj/bracketleftbigˆdjˆb†+ˆd† jˆb/bracketrightbig (100) between the oscillators and a bath. The subscript on ˆξmodmeans that we take the quadrature operators modulo a translation bylMsech/bracketleftig Σ−1 0/bracketrightig M−1sj, which comes from the branching of the logarithmic function. We choose to remove this condition on the quadrature operator, and instead apply this symmetry condition on the whole unitary ˆUj. The cooling rateΓ j(dimensionless) is then fixed by this condition. Under a few assump- tions (see Ref. [14]), we modelize the bath as a qubit withb=σx+iσy√ 2that is discarded after each interaction. We also use a second-order Trotterization on the oscillator-bath interaction. This leads to an approximation of the unitary in Eq. (100): ˆUj≈exp/parenleftbigg−ilΓj 2sT jΩMsinh/parenleftig Σ−1 0/parenrightig ΩM−1/bracketleftigˆξ−µE/bracketrightig σy/parenrightbigg (101) ×exp/parenleftig −ilΓjsT jΩMcosh/parenleftig Σ−1 0/parenrightig M−1/bracketleftigˆξ−µE/bracketrightig σx/parenrightig (102) ×exp/parenleftbigg−ilΓj 2sT jΩMsinh/parenleftig Σ−1 0/parenrightig ΩM−1/bracketleftigˆξ−µE/bracketrightig σy/parenrightbigg . Asking for this unitary to be symmetric under the translation mentioned before results in the expression Γj=/parenleftig sT jM−Ttanh/parenleftig Σ−1 0/parenrightig M−1sj/parenrightig−1(103) for the cooling rate. This unitary can be cast in a circuit that is implemented only with controlled displacements and qubit rotations CˆT(v) = exp/parenleftbigg −ilvTΩˆξˆσz 2/parenrightbigg , Rx(θ) = exp/parenleftbigg −iθˆσx 2/parenrightbigg .(104) In this representation, we obtain the unitary operator ˆUj≈CˆT(αj)ˆRz/parenleftig lαT jΩµE/parenrightigˆR† x/parenleftbiggπ 2/parenrightbigg ˆRz/parenleftig −lβT jΩµE/parenrightig CˆT/parenleftig βj/parenrightig (105) ×ˆRz/parenleftig −lβT jΩµE/parenrightigˆRx/parenleftbiggπ 2/parenrightbigg ˆRz/parenleftig lαT jΩµE/parenrightig CˆT(αj),(106) with small and big controlled displacementsα jandβj, respectively defined as αj=−Msinh/parenleftig Σ−1 0/parenrightig MTΩsj sT jM−Ttanh/parenleftig Σ−1 0/parenrightig M−1sj,βj=2Mcosh/parenleftig Σ−1 0/parenrightig M−1sj sT jM−Ttanh/parenleftig Σ−1 0/parenrightig M−1sj.(107) This is the circuit presented in Fig. 1 of Sect. 4. A major difference with the sBs circuit of [14] is that the small and big displacements are not orthogonal for a general symplectic matrixM. Another difference is that, for non-zeroµE, we get additional correction to the qubit rotations. Those rotations can be combined with the originalπ/2rotations around theσxaxis to keep the number of operations constant. 25 C Wigner function of GKP codes projectors In this section, we derive the Wigner representation of the codespace projector of an arbitrary GKP code considering a gauge. As defined in [17,",
    "rotations. Those rotations can be combined with the originalπ/2rotations around theσxaxis to keep the number of operations constant. 25 C Wigner function of GKP codes projectors In this section, we derive the Wigner representation of the codespace projector of an arbitrary GKP code considering a gauge. As defined in [17, 18], an element of the grid λ∈Λof Eq. (8) with generator matrixSis related to an element of the stabilizer group Sup to a gaugeµ∈Z2N 2by the stabilizer equation: S=/braceleftig νµ(λ)ˆT(λ)|ψ⟩=|ψ⟩,∀λ∈Λ/bracerightig ,(108) where νµ(λ) = exp/parenleftig iπλTS−1/bracketleftig A◺S−Tλ+µ/bracketrightig/parenrightig ,(109) andA ◺is the lower triangular part of the symplectic Gram matrixA=SΩST. After movingtothecanonicalbasisS D=RSusingthematrixRinEq.(39), wehaveasimplified equation for the gauge νµ(λ) = exp/parenleftig iπaT[AD◺a+Rµ]/parenrightig ,(110) where we useda=S−T Dλ∈Z2N. This transformation does not change the properties of the code, and we obtain the codespace projector as ΠS=/summationdisplay λ∈Λνµ(λ)ˆT(λ)(111) The Wigner representation of this projector is then computed using the definition in Eq. (17) W(ξ,ΠS) =/integraldisplay R2Ndve−i2πξTΩvTr/bracketleftigˆT(v) ΠS/bracketrightig ,(112) W(ξ,ΠS) =/summationdisplay λ∈Λνµ(λ)/integraldisplay R2Ndve−i2πξTΩvTr/bracketleftigˆT(v) ˆT(λ)/bracketrightig .(113) Since translation operators are trace orthogonal: Tr/bracketleftigˆT(v) ˆT(λ)/bracketrightig =δ2N(v+λ), we obtain W(ξ,ΠS) =/summationdisplay λ∈Λνµ(λ)ei2πξTΩλ.(114) W(ξ,ΠS) =/summationdisplay a∈Z2Nexp/parenleftigg πiaTAD◺a+ 2πi/bracketleftbiggR 2µ−SDΩξ/bracketrightbiggT a/parenrightigg ,(115) which can be rewritten in terms of a multivariable theta function [38] W(ξ,ΠS) =1 det(Λ)ϑ/parenleftbiggR 2µ−SDΩξ;AD◺/parenrightbigg .(116) We can go further in the description using the symmetry of the theta function in the second argument. Reminding ourselves thatA D= Ω 2⊗D, only the components for whichD kkis odd contribute to a non-trivial phase. Defining the matrixD 2= (D⊕D)mod2, we can split the infinite sum into two part onb∈Z2Nandm∈Z2N 2: a= (I 2N+D 2)b+D 2m.(117) This manipulation separates the even and odd components of the vectora, but only on the part for which the lattice is not symplectically even : ak=/braceleftigg bk ifDkkmod2 = 0 2bk+mkifDkkmod2 = 1(118) 26 Using this change of sommation indexing, we find that the products(I 2N+D 2)AD◺= AD◺(I2N+D 2)is an even matrix in2Z2N×2N. This simplify the Wigner function of Eq. (115) to /summationdisplay m∈Z2N 2e/parenleftig πimTD2AD◺D2m+2πi/bracketleftbigD2R 2µ−D 2SDΩξ/bracketrightbigTm/parenrightig /summationdisplay b∈Z2Ne2πi/bracketleftig (I+D 2)R 2µ−(I+D 2)SDΩξ/bracketrightigT b. (119) The first sum inm, that we noteC(S,µ,ξ), is finite and can be computed for a specified lattice. For the second series, we can compute it as a product of Poisson summations to find /summationdisplay b∈Z2Ne2πi/bracketleftig (I+D 2)R 2µ−(I+D 2)SDΩξ/bracketrightigT b=1 det/parenleftig˜Λ/parenrightig/summationdisplay ˜λ∗∈˜Λ∗δ(2N)/parenleftbigg ξ−/bracketleftbigg ˜λ∗−1 2S∗µ/bracketrightbigg/parenrightbigg (120) withS∗= ΩS−1. We have also defined a partially rescale lattice ˜Λ: ˜Λ =/braceleftig [(I+D 2)SD]Ta|a∈Z2N/bracerightig ,(121) and its symplectic dual lattice ˜Λ∗=/braceleftig Ω [(I+D 2)SD]−1a|a∈Z2N/bracerightig ,(122) We finally arrive at the result for the Wigner function for the projector onto the codespace of a GKP code with generator matrixSand gaugeµ: W(ξ,ΠS) =1 det/parenleftig˜Λ/parenrightigC(S,µ,ξ)/summationdisplay ˜λ∗∈˜Λ∗δ(2N)/parenleftbigg ξ−/bracketleftbigg ˜λ∗−1 2S∗µ/bracketrightbigg/parenrightbigg .(123) For the final result of this section, we produce the Wigner function of a pure grid state |ΨS⟩. Provided that we are looking at the projector over a pure GKP grid state|Ψ S⟩. Then, the Wigner function of the projector on|Ψ S⟩is the Wigner function of the state itself. In this case, because the canonical symplectic Gram matrix is onlyΩ,D 2=Iand Eq. (123) simplify to W(ξ,|ΨS⟩) =C(S,µ,ξ) 42N/summationdisplay λ∗∈Λ∗δ(2N)/parenleftbigg ξ−1 2[λ∗−S∗µ]/parenrightbigg ,(124) with ˜S= 2S.",
    "projector over a pure GKP grid state|Ψ S⟩. Then, the Wigner function of the projector on|Ψ S⟩is the Wigner function of the state itself. In this case, because the canonical symplectic Gram matrix is onlyΩ,D 2=Iand Eq. (123) simplify to W(ξ,|ΨS⟩) =C(S,µ,ξ) 42N/summationdisplay λ∗∈Λ∗δ(2N)/parenleftbigg ξ−1 2[λ∗−S∗µ]/parenrightbigg ,(124) with ˜S= 2S. As a result, all grid states can be represented in phase-space as a sum of Dirac delta functions positioned at half the dual lattice vectors under a trivial gauge (µ=0): W(ξ,|ΨS⟩)∝/summationdisplay λ∗∈Λ∗C/parenleftbigg S,0,λ∗ 2/parenrightbigg δ(2N)/parenleftbigg ξ−λ∗ 2/parenrightbigg .(125) D Wigner function of multimode finite energy GKP codes states As described in the main text, a general pure grid state of a finite energy GKP code is described by the infinite energy grid state and an envelopeE(Σ E,µE): /vextendsingle/vextendsingleΨS,ΣE,µE/angbracketrightbig=ˆE(ΣE,µE)|ΨS⟩.(126) 27 Inthissection, wederivetheWignerrepresentationofthisfiniteenergygridstateasafunc- tion ofS,Σ EandµE. The Wigner representation of this state has a simple decomposition as a star-product of Wigner functions of the envelope and the infinite energy state W/parenleftbigξ,/vextendsingle/vextendsingleΨS,ΣE,µE/angbracketrightbig/parenrightbig=W/parenleftig ξ,ˆE/parenrightig ⋆W(ξ,|Ψ S⟩)⋆W/parenleftig ξ,ˆE/parenrightig .(127) This star-product is defined as A⋆B:=AN/productdisplay j=1exp/parenleftbiggi 2/bracketleftig⃗∂qj⃗∂pj−⃗∂pj⃗∂qj/bracketrightig/parenrightbigg B(128) with⃗∂athepartialderivativewithrespecttoaactinginthedirectionofthearrow. Another equivalent definition for the star-product is [39] A(ξ)⋆B(ξ) = 22N/integraldisplay R2NdηdνA(ξ+η)B(ξ+ν) e4πiηTΩν,(129) which has been rescaled according to our definition of the Wigner function in Eq. (17). This product is associative and bilinear. Combining the argument of bilinearity with the result of the last section that a grid state has a Wigner function that decomposes as a sum of Dirac delta functions (See Sect. C), Eq. (127) reduces to W/parenleftbigξ,/vextendsingle/vextendsingleΨS,ΣE,µE/angbracketrightbig/parenrightbig=/summationdisplay λ∗∈Λ∗cλ∗W/parenleftig ξ,ˆE/parenrightig ⋆δ(2N)/parenleftbigg ξ−1 2[λ∗−S∗µ]/parenrightbigg ⋆W/parenleftig ξ,ˆE/parenrightig .(130) wherecλ∗=C/parenleftig S,µ,λ∗ 2/parenrightig /42N. Then, we only need to compute each term of the sum: W/parenleftig ξ,ˆE/parenrightig ⋆δ(2N)(ξ−χ)⋆W/parenleftig ξ,ˆE/parenrightig .(131) To achieve this, we first compute the Wigner representation of the envelope. A general envelope ˆE(ΣE,µE)can always be decomposed as a displaced and squeezed Gaussian function ˆE(ΣE,µE) =ˆE/parenleftig MEΣ0MT E,µE/parenrightig =ˆT(µE)UMEˆE(Σ 0,0)U† MEˆT(µE)†,(132) whereΣ 0is the symplectic diagonalisation ofΣ E. This canonical form of the envelope is connected to a thermal state of temperatureΣ−1 0in multiple modes. They are explicitly related as ˆE(Σ 0,0) =1/radicalbigg det/parenleftig I−exp/parenleftig −Σ−1 0/parenrightig/parenrightigˆρthermal.(133) The full thermal state is the product of one-mode thermal states. Therefore,ˆρ thermalis a product of Gaussian states with zero mean and covariance matrix(2 nk+ 1)I/4π[27], wherenkis the mean number of excitation in modek. Alternatively, we can use the connection nk= [exp (ε k)]−1between excitation number and temperature of the thermal state to find that its covariance matrix can also be written ascoth (ε k/2)I/4π. Combining Nsingle-mode thermal states result in a Gaussian function with a covariance matrix 1 4πcoth/parenleftig Σ−1 0/2/parenrightig .(134) 28 Using this connection with the thermal state, we find that the Wigner representation of this simple envelope is given by W/parenleftig ξ;ˆE(Σ 0,0)/parenrightig = det/parenleftig I−exp/parenleftig −Σ−1 0/parenrightig/parenrightig−1/2G1 4πcoth(Σ−1 0/2),0(ξ),(135) withGdefined in Eq. (21). From this result, we can obtain the Wigner representation of a general envelope by using Eq. (19): W/parenleftig ξ;ˆE(ΣE,µE)/parenrightig = det/parenleftig I−exp/parenleftig −Σ−1 0/parenrightig/parenrightig−1/2G1 4πMEcoth(Σ−1 0/2)MT E,µE(ξ).(136) To simplify the notation, we rewrite this last equation as W/parenleftig ξ;ˆE(ΣE,µE)/parenrightig =NGA,a(ξ),(137) whereA=1 4πMEcoth/parenleftig Σ−1 0/2/parenrightig MT Eanda=µE. With this intermediate result, we can",
    "result, we can obtain the Wigner representation of a general envelope by using Eq. (19): W/parenleftig ξ;ˆE(ΣE,µE)/parenrightig = det/parenleftig I−exp/parenleftig −Σ−1 0/parenrightig/parenrightig−1/2G1 4πMEcoth(Σ−1 0/2)MT E,µE(ξ).(136) To simplify the notation, we rewrite this last equation as W/parenleftig ξ;ˆE(ΣE,µE)/parenrightig =NGA,a(ξ),(137) whereA=1 4πMEcoth/parenleftig Σ−1 0/2/parenrightig MT Eanda=µE. With this intermediate result, we can move on to compute Eq. (131). Starting with the left star-product, we have W/parenleftig ξ,ˆE/parenrightig ⋆δ(2N)(ξ−χ) = 22NN/integraldisplay R2NdηdνGA,a(ξ+η)δ(2N)(ξ+ν−χ) e4πiηTΩν. (138) We then use a change of variable ˜η=η+ξ (138) = 22NN/integraldisplay R2Ndνδ(2N)(ξ+ν−χ) e−4πiξTΩν/integraldisplay R2Nd˜ηGA,a(˜η) e4πi˜ηTΩν.(139) The integral over ˜ηcan be identified as the characteristic function of a Gaussian distribu- tion at the position4πΩνto obtain (138) = 22NN/integraldisplay R2Ndνδ(2N)(ξ+ν−χ) e4πi[a−ξ]TΩνexp/parenleftigg −16π2 2νTΩAΩTν/parenrightigg .(140) We complete the computation of the product using the Dirac delta distribution inside the integral (138) = 22NNe4πi[ξ−a]TΩ[ξ−χ]exp/parenleftigg −16π2 2[ξ−χ]TΩAΩT[ξ−χ]/parenrightigg .(141) With the first star product computed, we now proceed to the second part (131) =22NN2/integraldisplay R2Ndηdνe4πi[ξ+η−a]TΩ[ξ+η−χ]× exp/parenleftigg −16π2 2[ξ+η−χ]TΩAΩT[ξ+η−χ]/parenrightigg GA,a(ξ+ν) e4πiηTΩν.(142) Once again, we use a change of variable ˜ν=ν+ξand identify the characteristic function of a Gaussian distribution to compute a first integral. Combining two Gaussian functions and using the propertyω(ν,ν) = 0to simplify phase terms, we arrive at Eq. (143) (131) =22NN2exp/parenleftigg −8π2 2[ξ−χ]TΩAΩT[ξ−χ]/parenrightigg e4πi[ξ−a]TΩ[ξ−χ]× /integraldisplay R2Ndηe4πi[ξ+χ−2a]TΩηexp/parenleftigg −32π2 2/bracketleftbigg η+ξ−χ 2/bracketrightbiggT ΩAΩT/bracketleftbigg η+ξ−χ 2/bracketrightbigg/parenrightigg .(143) 29 The last exponential function in Eq. (143) is linked to a Gaussian distribution function through exp/parenleftigg −32π2 2/bracketleftbigg η+ξ−χ 2/bracketrightbiggT ΩAΩT/bracketleftbigg η+ξ−χ 2/bracketrightbigg/parenrightigg =/radicaligg det/parenleftbiggA−1 16π/parenrightbigg GΩA−1ΩT 32π2,χ−ξ 2(η), (144) with det/parenleftigg A−1 16π/parenrightigg = 2−4Ndet/parenleftig tanh/parenleftig Σ−1 0/2/parenrightig/parenrightig ,(145) once we insert back the initial form ofA. With this identification, we can again use the definition of the characteristic function of a Gaussian distribution to compute this last integral (131) =/radicalbigg det/parenleftig tanh/parenleftig Σ−1 0/2/parenrightig/parenrightig N2exp/parenleftigg −8π2 2[ξ−χ]TΩAΩT[ξ−χ]/parenrightigg e4πi[ξ−a]TΩ[ξ−χ]× /integraldisplay R2Ndηei(−4πΩ[ξ+χ−2a])TηGΩA−1ΩT 32π2,χ−ξ 2(η). (146) After a few manipulations, we get the simplified equation (131) =/radicalbigg det/parenleftig tanh/parenleftig Σ−1 0/2/parenrightig/parenrightig N2exp/parenleftigg −8π2 2[ξ−χ]TΩAΩT[ξ−χ]/parenrightigg × exp/parenleftigg −1 2[ξ+χ−2a]TA−1 2[ξ+χ−2a]/parenrightigg .(147) At this point, it is useful to combine both exponentials into a single Gaussian function by completing the square in the exponent. After inserting the definition ofAandainto Eq. (147), we get (131) =/radicalbigg det/parenleftig tanh/parenleftig Σ−1 0/2/parenrightig/parenrightig det/parenleftig I−exp/parenleftig −Σ−1 0/parenrightig/parenrightigexp −1 2[χ−µE]T MEcoth/parenleftig Σ−1 0/parenrightig MT E 4π −1 [χ−µE] × exp −1 2[ξ−χE]T MEtanh/parenleftig Σ−1 0/parenrightig MT E 4π −1 [ξ−χE] , (148) where we have extracted the altered peak position χE=MEsech/parenleftig Σ−1 0/parenrightig M−1 E[χ−µE] +µE.(149) Equation (148) tells us that the normalization process of adding a Fock-type envelope to a GKP state Wigner function maps each Dirac distribution of the sum in Eq. (130) to a Gaussian function of amplitude described by the first line of Eq. (148), centered aroundχE and with covariance matrixM Etanh/parenleftig Σ−1 0/parenrightig MT E/4π. This describes entirely the Wigner function of any finite-energy GKP state with a Fock-type envelope. Especially, Eq. (148) reduces to the result of Ref. [36] whenM E=IandµE=0. If we setΣ 0=α−1Iand take the limitα→0+, we recover the infinite energy state. In this limit, the peaks position are unalteredχE→χ, each peak is infinitely squeezed with an infinite amplitude because tanh",
    "GKP state with a Fock-type envelope. Especially, Eq. (148) reduces to the result of Ref. [36] whenM E=IandµE=0. If we setΣ 0=α−1Iand take the limitα→0+, we recover the infinite energy state. In this limit, the peaks position are unalteredχE→χ, each peak is infinitely squeezed with an infinite amplitude because tanh (Σ 0)→0and the envelope becomes infinitely large becausecoth (Σ 0)→∞. 30 E Average number of excitation in GKP states In this section, we aim to obtain an expression for the average number of excitations in a GKP state with generator matrixSand an envelope described by covariance matrixΣ E and position in phase-spaceµE. In Sect. D, we have derived the Wigner function of such a state, and in the following, we are going to use this result. From our definition of the Wigner function W(ξ,ˆρ) =/integraldisplay R2Ndve−i2πξTΩvTr/bracketleftigˆT(v) ˆρ/bracketrightig ,(150) we can derive the expression for the average excitation number [40] /angbracketleftbigg ˆξTˆξ/angbracketrightbigg =Tr/bracketleftbigg ˆξTˆξˆρ/bracketrightbigg = (2π)2N/integraldisplay R2NdξξTξW(ξ,ˆρ),(151) for a state described by the Wigner functionW(ξ,ˆρ). With this intermediate result, we are ready to compute it with the Wigner function of GKP states from Eq. (148). To simplify the demonstration, we express the Wigner function of GKP states as W(ξ,ˆρ GKP) =/summationdisplay χ∈Mcχexp/parenleftbigg−1 2[ξ−χE]TB−1[ξ−χE]/parenrightbigg ,(152) withM= (Λ∗−S∗µ)/2from Eq. (124),χ Efrom Eq. (149) and B=MEtanh/parenleftig Σ−1 0/parenrightig MT E/4π. This leads us to compute the integral /angbracketleftbigg ˆξTˆξ/angbracketrightbigg = (2π)2N/summationdisplay χ∈Mcχ/integraldisplay R2NdξξTξexp/parenleftbigg−1 2[ξ−χE]TB−1[ξ−χE]/parenrightbigg .(153) This is an integral that we can compute analytically using a change of variable and adding a source term. We reframe the problem as solving the integral /integraldisplay R2Ndξ[ξ+χE]T[ξ+χE] exp/parenleftbigg−1 2ξTB−1ξ+JTξ/parenrightbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle J=0.(154) With this trick, we can move the polynomial term out of the integral by changing the variable for derivatives inJ /bracketleftbigg∂ ∂J+χE/bracketrightbiggT/bracketleftbigg∂ ∂J+χE/bracketrightbigg/integraldisplay R2Ndξexp/parenleftbigg−1 2ξTB−1ξ+JTξ/parenrightbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle J=0,(155) and we obtain a multivariate Gaussian integral. The result of this integral is (2π)N/radicalig det (B)/bracketleftbigg∂ ∂J+χE/bracketrightbiggT/bracketleftbigg∂ ∂J+χE/bracketrightbigg exp/parenleftbigg1 2JTBJ/parenrightbigg/vextendsingle/vextendsingle/vextendsingle/vextendsingle/vextendsingle J=0,(156) and we can reduce it to (2π)N/radicalig det (B)/parenleftig χT EχE+Tr[B]/parenrightig ,(157) which is the contribution to energy from one Gaussian peak of the GKP Wigner function. Putting everything together and doing simplifications on prefactors, we arrive at the result 31 that the average number of excitations in a GKP state described by the generator matrix Sand envelope(Σ E,µE) =/parenleftig MEΣ0MT E,µE/parenrightig is /angbracketleftbigg ˆξTˆξ/angbracketrightbigg =π2N/radicalbigg det/parenleftig I+ tanh/parenleftig Σ−1 0/parenrightig/parenrightig/summationdisplay χ∈Mcχ/parenleftig χT EχE+Tr/bracketleftig MEtanh/parenleftig Σ−1 0/parenrightig MT E/bracketrightig/parenrightig ×exp −1 2[χ−µE]T MEcoth/parenleftig Σ−1 0/parenrightig MT E 4π −1 [χ−µE] .(158) As a final remark, we can also obtain the number of excitations in a sub-system (in a single mode, for example) by restricting the scalar product and trace in Eq. (157) to be only over elements of this sub-system and rescaling the prefactors accordingly. 32"
  ]
}